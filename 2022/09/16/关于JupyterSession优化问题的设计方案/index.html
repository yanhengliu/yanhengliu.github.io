<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="聂小涛的博客">
    <meta property="og:type" content="website">
    <meta name="description" content="聂小涛的博客">
    <meta name="keyword"  content="hexo,聂小涛,聂小涛的博客,全栈开发,Aircloud">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        关于 JupyterLab cell 输出保持问题的设计方案 - AirCloud 日常
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="AirCloud 日常" type="application/atom+xml">
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> Keep Recording⏺️ </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>卷毛 Yanheng Liu</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%98%E8%A6%81"><span class="toc-text">摘要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%A6%82%E8%BF%B0"><span class="toc-text">问题概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A5%E9%97%AE%E9%A2%98%E7%9A%84%E7%A4%BE%E5%8C%BA%E8%AE%A8%E8%AE%BA%E5%92%8C%E6%88%90%E5%9B%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">该问题的社区讨论和成因概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BE%E5%8C%BA%E7%8E%B0%E7%8A%B6"><span class="toc-text">社区现状</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%A6%82%E8%BF%B0"><span class="toc-text">解决方案概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Workspace-%E4%BF%AE%E6%94%B9"><span class="toc-text">1. Workspace 修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Notebook-kernel-uuid"><span class="toc-text">2. Notebook kernel uuid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Notebook-cell-uuid"><span class="toc-text">3. Notebook cell uuid</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B0%E5%A2%9E%E6%81%A2%E5%A4%8D%E9%80%BB%E8%BE%91"><span class="toc-text">4. 新增恢复逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84"><span class="toc-text">本文解决方案的不足之处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-text">扩展阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D-Jupyter-Notebook-Kernel-%E7%9A%84%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B"><span class="toc-text">当前 Jupyter Notebook-Kernel 的架构模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%93%BE%E6%8E%A5"><span class="toc-text">其他链接</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> Keep Recording⏺️ </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        关于 JupyterLab cell 输出保持问题的设计方案
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2022-09-16 19:15:51</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#前端综合" title="前端综合">前端综合</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文试图尝试阐述目前 JupyterLab 当前存在的 cell 输出保持问题的原因，并且给出一个基于当前 Jupyter 架构的解决方案。</p>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>这个问题，简单描述为就是当我们在 JupyterLab Notebook 中执行一个耗时代码，如果此时我们因为某些原因刷新或者关闭重新打开了页面，我们就永远无法继续跟踪输出了。</p>
<p>我们通过一个例子来更直观地感受：</p>
<p>JupyterLab 在 NodeBook 中运行如下的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;current: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/img/jupyter_cell1.png" alt="跟踪日志"></p>
<p>如果此时你强制刷新页面，就会发现标准输出丢失，并且这个时候没有办法再找到。</p>
<h2 id="该问题的社区讨论和成因概述"><a href="#该问题的社区讨论和成因概述" class="headerlink" title="该问题的社区讨论和成因概述"></a>该问题的社区讨论和成因概述</h2><blockquote>
<p>如果只关注解决方案，可以直接滚动至下文解决方案部分</p>
</blockquote>
<h3 id="社区现状"><a href="#社区现状" class="headerlink" title="社区现状"></a>社区现状</h3><ul>
<li>在 2015 年这个问题就被提出来了，不过因为它和当前 jupyter 的架构有所冲突，需要对 server 端进行巨大的重构，所以就一直搁置，<strong>官方至今未修复此问题</strong>。</li>
<li>社区一些曲折方案，但是所有方案<strong>都需要使用者代码改动或者安装额外插件</strong>，笔者对其中一些方案进行列举：<ul>
<li>有人提出使用 ipycache 这个插件，可以保存输出，不至于让输出丢失，但仍然不能监控进度，而且要写一些额外代码，相对来说还是会比较麻烦。</li>
<li>还有人提出使用 <code>%%capture var</code> 来捕获一些 stderr，通过 <code>var.show()</code> 来显示，同样的，这个也是只能等到执行完 cell 之后。</li>
<li>第三个类似的方案：<code>sys.stdout = open(&#39;my_log.log&#39;, &#39;w&#39;)</code></li>
</ul>
</li>
<li>目前 JupyterLab V4 版本正在进行 <a target="_blank" rel="noopener" href="https://github.com/jupyterlab/jupyterlab/issues/5382">Real Time Collaboration</a> 功能的开发，涉及到很大的改动，<strong>在原本的计划中，会顺带把这个问题修复掉</strong>。<ul>
<li><em>V4 版本在 22 年 5月左右开始发布 alpha 版本，目前仍然处于 alpha 阶段，乐观来讲明年年初也许可以 Release 正式版本（P.S. 我们现在一般用的是 V3， 的 21 年 11月左右发布的一个较为稳定的版本）</em></li>
</ul>
</li>
<li>在 2022 年的 5 月 19 日，这个问题被移动到了 Jupyter 的<a target="_blank" rel="noopener" href="https://github.com/jupyterlab/jupyterlab/projects/12#card-65141043">任务看板</a>之中，不过目前<strong>没有负责人</strong>。</li>
</ul>
<p>总之，解决这个问题的主要困境为：</p>
<ul>
<li>在现有架构上无法很好地解决，需要新增模块，在架构上做变更，而且需要改动 server 部分（和 notebook 共用），同时向前兼容。</li>
<li>需要对 Jupyter 以及其周边实现理解非常深刻，并且对 Jupyter 正在和将要进行的工作非常熟悉，特别是 RTC 部分，才有可能解决并将代码合入主干。<ul>
<li>而 RTC 又是一个非常复杂、暂时很难完全 release 的功能，所以如果基于 RTC 去设计解决方案，很可能你在一年内都无法上线 Jupyter 正式版</li>
</ul>
</li>
<li>解决该问题需要花费的时间较多，沉没成本高，所以很多有一些想法的研究者，也只是眼巴巴希望官方能解决。</li>
</ul>
<h2 id="解决方案概述"><a href="#解决方案概述" class="headerlink" title="解决方案概述"></a>解决方案概述</h2><p>我们这里经过权衡，设计出一套不依赖 RTC 功能解决该问题的方案。</p>
<p>我们主要需要改动一下几点：</p>
<ol>
<li><strong>修改 JupyterLab Workspace 机制，改成唯一 ID</strong></li>
<li><strong>修改 JupyterLab Notebook 连接 kernel 的 UUID 逻辑，改成非随机的 UUID</strong></li>
<li><strong>修改发消息的 msg ID，改为非随机的 UUID</strong></li>
<li><strong>新增恢复逻辑，根据 message 的 UUID 将输出写入到对应 cell</strong></li>
<li>[可选] Server 端保留更多输出内容</li>
</ol>
<p>改动的范围主要是 JupyterLab 前端 packages 下的各个模块，后端部分需配合做少量修改。</p>
<p>接下来我们依次详细说明以下改动</p>
<h3 id="1-Workspace-修改"><a href="#1-Workspace-修改" class="headerlink" title="1. Workspace 修改"></a>1. Workspace 修改</h3><p>JupyterLab 的 workspace 实际上就是你打开多个 JupyterLab 之后，URL 中 <code>/lab/workspaces/***</code> 后面的那一串，JupyterLab 会针对不同的 Workspace 存储不同的布局等信息，不过笔者认为，Jupyter 的 Workspace 还是有一定缺陷的，接下来会进行详细分析。</p>
<p><strong>在同一个浏览器里面：</strong></p>
<p>每当你打开一个 jupyter 页面，它会做这样几件事情：</p>
<ol>
<li>获取下当前自己的 workspace 名字，如果 url 里面有 workspace 参数就用 url 里面的，如果没有就用默认名字（第一个打开的页面一般是没有的），比如 <code>default</code></li>
<li>在 localstorage 里面写一个 <code>ping</code>，并 <code>window.addEventListener(&#39;storage&#39;)</code> 来接受其他页面的 <code>pong</code><ul>
<li>其他已经打开的同源 jupyter 页面，也会通过 <code>window.addEventListener(&#39;storage&#39;)</code> 监听 <code>ping</code> 并返回 <code>pong</code>，携带自己的 workspace 名字</li>
<li>这样，这个页面就知道当前有哪些页面打开了</li>
</ul>
</li>
<li>如果其他已经打开的页面里面有重名的 workspace，这个时候：<ul>
<li>它从 <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code> 中随机取一个随机数，组成 <code>auto-随机数</code>, 放到 workspace 参数里面，<strong>重启整个页面</strong></li>
<li>重启页面之后，重新执行步骤 1</li>
</ul>
</li>
</ol>
<p>因此：</p>
<ul>
<li>除了第一个 jupyter 页面以外，其他的 Tab 打开都是需要刷新两遍的</li>
<li>并且随着冲撞的概率变高，当你打开的 Tab 越多，新开的 Tab 的刷新次数期望值越高，也就是说，你等待的时间越长。</li>
</ul>
<p>因为一共就 62 个随机数，假设所有的随机数用完了，会发生什么？</p>
<p><strong>是的，JupyterLab 会直接无限循环 Reload, 无法使用，经过实测，确实如此。</strong></p>
<p><strong>在不同的浏览器里面：</strong></p>
<p>他们完全互不知情，因此：</p>
<p>不同浏览器直接打开的第一个 workspace 都叫做 default，后续的更多 tab 是否冲突看运气。<br>当你在不同的浏览器 JupyterLab，并且在 JupyterLab 里面打开了一些东西，之后原来浏览器 Tab 刷新，就会被影响到了，<strong>这个问题在多用户集群场景下会更加显著。</strong></p>
<p>同时，JupyterLab 后端会把 workspace 配置持久化到文件中，<strong>不过自身没有配置文件清理逻辑</strong></p>
<p>所以，针对 Workspace 我们整体的改动为：</p>
<ul>
<li>去掉默认的 Workspace 逻辑。</li>
<li>Workspace 的 id 变成 uuid，保证大家即使不同浏览器访问也不一致。</li>
<li>添加 Workspace 配置数据的清理逻辑，定时清理很久没有在用的 Workspace 信息。</li>
</ul>
<h3 id="2-Notebook-kernel-uuid"><a href="#2-Notebook-kernel-uuid" class="headerlink" title="2. Notebook kernel uuid"></a>2. Notebook kernel uuid</h3><blockquote>
<p>这部分可以结合下文“扩展阅读”，来更加深入地了解。</p>
</blockquote>
<p>目前，当我们打开一个 Notebook 的时候，默认 Jupyter 就会新开一个 Kernel，然后前端 Notebook 通过建立 websocket(有一个叫做 <code>KernelConnection</code> 的类来管理 websocket) 来和 Kernel 通信。</p>
<p>同一个 Notebook，会随机生成一个 uuid，这个 uuid 是在 KernelConnection 管理类创建的时候生成的：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">KernelConnection</span> <span class="title">implements</span> <span class="title">Kernel</span>.<span class="title">IKernelConnection</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a kernel object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">options: Kernel.IKernelConnection.IOptions</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 一般而言这里的 clientId 都是空</span></span><br><span class="line">    <span class="built_in">this</span>._clientId = options.clientId ?? UUID.uuid4();</span><br><span class="line">    <span class="comment">// 其他逻辑...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后对于非广播的消息（这里比如 kernel 的状态，它就是一个广播消息，而 python 代码块的具体执行，它是一个非广播消息，这一点更多也可以参考下文扩展阅读），是只会发送到这个 uuid 对应的 KernelConnection 客户端。</p>
<p>也因此，当目前刷新页面之后，<strong>这个 uuid 就变了</strong>，这个时候就无法对接到之前的非广播消息。</p>
<p>那么 JupyterLab 为什么不保持 uuid 不变呢，主要说法是：</p>
<ol>
<li>如果你打开了多个 Tab，它们使用相同的 uuid，这个必然会造成消息发送紊乱，实际上这样在建立连接的这步就会失败。</li>
<li>有的时候，客户端会短暂断网，这个时候对应 uuid 的 websocket 会断连，假设后面再连接上，不知道是新的页面还是当前的网络恢复了，后端不知道这个信息，因此会对设计 uuid 复用逻辑有所影响。</li>
</ol>
<p>所以，如果我们改变 uuid 的策略，需要在保证 Workspace 的唯一的前提下，设计连接 websocket 的 uuid 为 <strong><code>workspaceId - notebookId</code></strong></p>
<h3 id="3-Notebook-cell-uuid"><a href="#3-Notebook-cell-uuid" class="headerlink" title="3. Notebook cell uuid"></a>3. Notebook cell uuid</h3><p>在上一点我们更改了一个 Notebook 连接 kernel 的 uuid，但是对于其中一个 cell 的 uuid 还是随机的，这会导致即使 kernel 收到了消息，也无法得知这个消息是属于哪个 cell。</p>
<p>我们梳理下目前 cell 执行 python 代码的过程，接下来我们简化这个过程：</p>
<ol>
<li>当我们点击按钮，执行一个 cell 的代码的时候，Notebook 会构造这样的一条消息：</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMessage</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Message</span>&gt;(<span class="params">options: IOptions&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">buffers</span>: options.buffers ?? [],</span><br><span class="line">    <span class="attr">channel</span>: options.channel,</span><br><span class="line">    <span class="attr">content</span>: options.content,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>().toISOString(),</span><br><span class="line">      <span class="comment">// msgId 一般也是没有的</span></span><br><span class="line">      <span class="attr">msg_id</span>: options.msgId ?? UUID.uuid4(),</span><br><span class="line">      <span class="attr">msg_type</span>: options.msgType,</span><br><span class="line">      <span class="attr">session</span>: options.session,</span><br><span class="line">      <span class="attr">username</span>: options.username ?? <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">version</span>: <span class="string">&#x27;5.2&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">metadata</span>: options.metadata ?? &#123;&#125;,</span><br><span class="line">    <span class="attr">parent_header</span>: options.parentHeader ?? &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>这条消息会调用上文提到的 <code>KernelConnection</code> 的实例方法 <code>sendShellMessage</code>，<code>sendShellMessage</code> 会把消息发送给后端，同时维护一个基于 <code>msgId</code> 的绑定关系。</p>
</li>
<li><p>后端 Kernel 执行完之后返回消息。返回的消息和发送的消息比较类似，比较重要的字段是 <code>parent_header</code>，<code>parent_header</code> 即发送的消息体中的 <code>header</code> 字段，其中存储 <code>msgId</code>。</p>
</li>
<li><p>Notebook 客户端收到消息后，通过 <code>parent_header</code> 中的 <code>msgId</code> 找到对应的 cell（这里实际上是执行一个 callback，callback 通过闭包捕获之前 cell 的相关引用），然后更新状态。</p>
</li>
</ol>
<p>也就是说，当我们更改 cell 的 msgId 计算方式的时候，实际上大多数时候上面的逻辑都是没有变化的，只是在刷新页面之后，因为这个时候之前的回调等逻辑是不存在的，我们需要手动找到这个 cell，然后把结果输出。</p>
<h3 id="4-新增恢复逻辑"><a href="#4-新增恢复逻辑" class="headerlink" title="4. 新增恢复逻辑"></a>4. 新增恢复逻辑</h3><p>基于上文我们 Workspace 和 uuid 的更新设计，我们已经可以把一个页面的一条消息对应到一个 cell 中，并且这里的绑定信息是可推断、可持久化、非随机的，也就是说，我们已经有了完成恢复功能的能力。</p>
<p>不过实际上要完成这个逻辑，还要加的内容非常多，Notebook cell 执行相关的逻辑本身状态判断较多且调用复杂，我们新加直接输出的逻辑不仅需要融入到现有的逻辑中，而且需要考虑各种边界情况，<strong>无异于做一次重构</strong>。</p>
<p>也因为第四点过于复杂，笔者并没有完全验证，只是依靠控制台输出做了一些分析验证可行性的工作。</p>
<h2 id="本文解决方案的不足之处"><a href="#本文解决方案的不足之处" class="headerlink" title="本文解决方案的不足之处"></a>本文解决方案的不足之处</h2><p>本文提供的解决方案，能够解决我们遇到的输出丢失问题，不过同时，它也是有一些副作用的，比如：</p>
<ul>
<li><strong>Notebook 修改名称逻辑会更复杂：</strong>因为设计上是将一个 Notebook 和它的 uuid 对应起来，实际上对于 Notebook 来说，它自身的 uuid 也就是它的路径名等信息，它并不存在一个类似 <code>文件 uuid</code> 的概念，所以当文件名称变了，这个 uuid 也会跟着变化，这里的方案可能是：<ul>
<li>当 kernel 繁忙的时候不允许改名，因为这个时候改名会导致 uuid 变化，这样输出就丢失了，并把这个信息提示给用户。（事实上，这类交互在软件设计中不难见到，比如在 macOS 中，一个文件在拷贝的过程中是不允许改名的，所以笔者觉得这个也是可以被接受的）。</li>
<li>或者在 jupyter server 记录文件的更名信息，这样当改名的时候，我们可以通过一些临时记录保证长链接不变（但这样会设计的比较复杂，不是很建议）。</li>
</ul>
</li>
</ul>
<h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>为了方便更加深入了解 JupyterLab Client-&gt;Kernel 的架构，我们补充一些扩展信息。</p>
<h3 id="当前-Jupyter-Notebook-Kernel-的架构模型"><a href="#当前-Jupyter-Notebook-Kernel-的架构模型" class="headerlink" title="当前 Jupyter Notebook-Kernel 的架构模型"></a>当前 Jupyter Notebook-Kernel 的架构模型</h3><p>当前的 Jupyter 的 Notebook-Kernel 是一个多对一的架构，也就是说，我们可以开多个页面连接到相同的一个 Kernel，同时每个页面都执行不同的 cell，它们是都可以正确的和输出对应起来的。</p>
<p><img src="/img/jupyter_frontend_kernel.webp"></p>
<p>同时，对于一些比如 kernel 状态的信息，是会广播给所有客户端的。</p>
<p>目前 Jupyter 通过 <a target="_blank" rel="noopener" href="https://github.com/jupyter/jupyter_client">jupyter_client</a> 这个包来和 kernel 进行管理和通信，这个包虽然叫做 client，但是是在 server 端，使用的，主要是和 jupyter 的 kernel 通信。</p>
<p>默认使用的是 <a target="_blank" rel="noopener" href="https://github.com/ipython/ipykernel">ipykernel</a></p>
<p>启动代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;/path/to/bin/python&#x27;, &#x27;-m&#x27;, &#x27;ipykernel_launcher&#x27;, &#x27;-f&#x27;, &#x27;/path/to/Jupyter/runtime/kernel-85259599-797f-4b21-b701-2a63c96fbe10.json&#x27;]</span><br></pre></td></tr></table></figure>

<p>kernel 文件中会存储通信端口等一些信息：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;shell_port&quot;</span>: <span class="number">57748</span>,</span><br><span class="line">  <span class="attr">&quot;iopub_port&quot;</span>: <span class="number">57749</span>,</span><br><span class="line">  <span class="attr">&quot;stdin_port&quot;</span>: <span class="number">57750</span>,</span><br><span class="line">  <span class="attr">&quot;control_port&quot;</span>: <span class="number">57752</span>,</span><br><span class="line">  <span class="attr">&quot;hb_port&quot;</span>: <span class="number">57751</span>,</span><br><span class="line">  <span class="attr">&quot;ip&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;ba04817a-be19696087459a6a772e6268&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;transport&quot;</span>: <span class="string">&quot;tcp&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;signature_scheme&quot;</span>: <span class="string">&quot;hmac-sha256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;kernel_name&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jupyter_client 使用 zmq 来做和 kernel 之间的通信。</p>
<h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/jupyterlab/jupyterlab/issues/2833">Reconnect to running session: keeping output</a></li>
<li><a target="_blank" rel="noopener" href="https://groups.google.com/g/jupyter">jupyter 邮件组</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jupyterlab/rtc">https://github.com/jupyterlab/rtc</a></li>
</ul>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        <li>
            <a target="_blank" href="https://twitter.com/iconie_alloy">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-twitter"></i>
                            </span>
            </a>
        </li>
        
        
        <li>
            <a target="_blank" href="https://www.zhihu.com/people/ai-er-lan-xue-da">
                            <span class="fa-stack fa-lg">
                                 <i class="iconfont icon-zhihu"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="http://weibo.com/3286578617">
                            <span class="fa-stack fa-lg">
                                  <i class="iconfont icon-weibo"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank" href="https://www.facebook.com/xiaotao.nie.5">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-facebook"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://github.com/AirCloud">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-github"></i>
                            </span>
            </a>
        </li>
        

        
        <li>
            <a target="_blank"  href="https://www.linkedin.com/in/小涛-聂-80964aba">
                            <span class="fa-stack fa-lg">
                                <i class="iconfont icon-linkedin"></i>
                            </span>
            </a>
        </li>
        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://www.10000h.top">10000H</a></span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://niexiaotao.com">Xiaotao&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="#">It helps SEO</a></span>
        <span>/</span>
        
        <span><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">浙ICP备16035324号-1</a></span>
        <span>/</span>
        
    </p>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>  Theme <a target="_blank" rel="noopener" href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://giscus.app/client.js"
    data-repo="aircloud/hexo-aircloud-blog"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxMjkwNDgyNjg="
    data-category="Announcements"
    data-category-id="DIC_kwDOB7EezM4COhKJ"
    data-mapping="title"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="light"
    data-lang="zh-CN"
    crossorigin="anonymous"
    async>
</script>




</html>
