<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AirCloud 日常</title>
  <icon>https://www.gravatar.com/avatar/2f58f77d5b516b291563686ed164bd51</icon>
  <subtitle>Keep Recording⏺️</subtitle>
  <link href="http://localhost:4000/atom.xml" rel="self"/>
  
  <link href="http://localhost:4000/"/>
  <updated>2023-10-04T08:13:48.980Z</updated>
  <id>http://localhost:4000/</id>
  
  <author>
    <name>卷毛 Yanheng Liu</name>
    <email>onlythen@yeah.net</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于记忆的体系和效率</title>
    <link href="http://localhost:4000/2023/10/04/%E8%AE%B0%E5%BF%86%E7%9A%84%E4%BD%93%E7%B3%BB%E5%92%8C%E6%95%88%E7%8E%87/"/>
    <id>http://localhost:4000/2023/10/04/%E8%AE%B0%E5%BF%86%E7%9A%84%E4%BD%93%E7%B3%BB%E5%92%8C%E6%95%88%E7%8E%87/</id>
    <published>2023-10-04T08:11:55.000Z</published>
    <updated>2023-10-04T08:13:48.980Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-了解工具"><a href="#1-了解工具" class="headerlink" title="1.了解工具"></a>1.了解工具</h3><p>选择一本公认的、权威的教材，将里面出现的术语全部弄明白。</p><h3 id="2-建立脉络"><a href="#2-建立脉络" class="headerlink" title="2.建立脉络"></a>2.建立脉络</h3><p>不求深度，求广度，纵览，建立整个领域的脉络。写出重点、特点。</p><h4 id="3-找出兴趣点"><a href="#3-找出兴趣点" class="headerlink" title="3.找出兴趣点"></a>3.找出兴趣点</h4><p>对整体领域中单个领域进行深入了解。</p><h3 id="4-加深记忆"><a href="#4-加深记忆" class="headerlink" title="4.加深记忆"></a>4.加深记忆</h3><p>金字塔原理。</p><h3 id="5-建立联系"><a href="#5-建立联系" class="headerlink" title="5.建立联系"></a>5.建立联系</h3><p>旧概念和新概念的联系，单一概念和拓展概念的联系，不同领域之间的联系。</p><ul><li>带着问题去学习。五个为什么。</li><li>做好笔记 INBOX -<br>NOTE - KNOWLEDGE</li></ul><p>想法、瞬间、看到、想到、认为、有价值的记录在 INBOX 上</p><p>完善 INBOX，发问-思考-拓展，将内容完善延伸、整理成一条笔记。放在 NOTE 里</p><p>每周定时将 NOTE 整理至同一主题，即 KNOWLEDGE</p><p>收集——完善——整理——（应用）——归档</p><p><img src="/img/memory.jpg"></p><h3 id="6-拓展应用"><a href="#6-拓展应用" class="headerlink" title="6.拓展应用"></a>6.拓展应用</h3><p>深入，挖掘，建立联系，将所有这些东西在思维层面整合起来，就是知识体系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-了解工具&quot;&gt;&lt;a href=&quot;#1-了解工具&quot; class=&quot;headerlink&quot; title=&quot;1.了解工具&quot;&gt;&lt;/a&gt;1.了解工具&lt;/h3&gt;&lt;p&gt;选择一本公认的、权威的教材，将里面出现的术语全部弄明白。&lt;/p&gt;
&lt;h3 id=&quot;2-建立脉络&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="个人笔记" scheme="http://localhost:4000/tags/%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2023书单</title>
    <link href="http://localhost:4000/2023/01/01/2023%E4%B9%A6%E5%8D%95/"/>
    <id>http://localhost:4000/2023/01/01/2023%E4%B9%A6%E5%8D%95/</id>
    <published>2023-01-01T12:20:20.000Z</published>
    <updated>2023-10-04T08:24:26.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机科学"><a href="#计算机科学" class="headerlink" title="计算机科学"></a>计算机科学</h2><ol><li>[嗨翻 C 语言](<a href="https://book.douban.com/subject/25703412/">嗨翻 C 语言 (豆瓣)</a>) - 2023.2.9-2023.2.20</li><li><a href="%E9%93%BE%E6%8E%A52">书名 2</a> - 作者 2</li></ol><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><ol><li><a href="%E9%93%BE%E6%8E%A53">书名 3</a> - 作者 3</li><li><a href="%E9%93%BE%E6%8E%A54">书名 4</a> - 作者 4</li></ol><h2 id="数据科学"><a href="#数据科学" class="headerlink" title="数据科学"></a>数据科学</h2><ol><li><a href="%E9%93%BE%E6%8E%A55">书名 5</a> - 作者 5</li><li><a href="%E9%93%BE%E6%8E%A56">书名 6</a> - 作者 6</li></ol><h2 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h2><ol><li><a href="%E9%93%BE%E6%8E%A57">书名 7</a> - 作者 7</li><li><a href="%E9%93%BE%E6%8E%A58">书名 8</a> - 作者 8</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机科学&quot;&gt;&lt;a href=&quot;#计算机科学&quot; class=&quot;headerlink&quot; title=&quot;计算机科学&quot;&gt;&lt;/a&gt;计算机科学&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;[嗨翻 C 语言](&lt;a href=&quot;https://book.douban.com/subject/2</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://localhost:4000/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>基于 K8s 容器化运行 web 端对端测试</title>
    <link href="http://localhost:4000/2022/11/18/%E4%BD%BF%E7%94%A8k8s%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E8%A1%8C%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/"/>
    <id>http://localhost:4000/2022/11/18/%E4%BD%BF%E7%94%A8k8s%E5%AE%B9%E5%99%A8%E5%8C%96%E8%BF%90%E8%A1%8C%E7%AB%AF%E5%AF%B9%E7%AB%AF%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/</id>
    <published>2022-11-18T13:06:06.000Z</published>
    <updated>2023-10-02T14:15:46.144Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前言：<br>日常开发中，如果你曾经遇到过类似问题：</p><ol><li>一个之前开发的、很久不维护的项目或页面，突然被告知无法访问或无法使用了。</li><li>一些重数据的页面，用户反馈有的时候数据对不上，但是自己开发的时候明明测过没有问题。<br>那么本文中提供的端对端测试，或许会给你解决这些问题带来一些帮助。</li></ol></blockquote><p>本文对使用 K8s 容器化运行 web 端对端测试用例进行介绍，对这个过程以及可能遇到的问题做一个整体的梳理，并且会穿插提供一定的参考资料。</p><p>相关示例代码已经开源：<a href="https://github.com/aircloud/easy-e2e">https://github.com/aircloud/easy-e2e</a></p><h2 id="为什么我们需要端对端测试"><a href="#为什么我们需要端对端测试" class="headerlink" title="为什么我们需要端对端测试"></a>为什么我们需要端对端测试</h2><p>端对端测试（也称 E2E 测试），通常是从最终用户的角度出发，模拟真实实用的场景，并验证经过一系列操作之后，用户界面的表现是否符合预期。</p><p>它比单元测试、集成测试、接口测试等更能够反映用户真实的使用情况，使用得当会对我们带来很大收益。</p><p>web 的端对端测试通常使用 <a href="https://github.com/puppeteer/puppeteer">Puppeteer</a> 等工具来完成，在下文中，端对端测试即指基于 Puppeteer 的 web 端对端测试。</p><p>笔者所在的团队中，会在以下场景中使用端对端测试：</p><ol><li>一些进入到维护阶段的项目：对于这类项目，我们没有办法继续投入测试资源，但是需要保证主流程正常，我们便可以通过定时端对端测试用例来进行每日测试并生成报告，端对端测试能够跑过即表示主流程运行正常，当每天收到“E2E测试全部通过”的报告，内心还是会多一丝安稳。</li><li>一些重逻辑的项目：各类监控统计、科学计算等平台型项目，这类项目通常会有各类计算逻辑，分散在前端、接入层和后端，甚至部分数据错误使用者也无法发现，这个时候，我们会通过端对端测试验证比如页面多处数据的一致性、数据更新时间是否及时、数据关联逻辑如累加、比例是否自洽等。</li></ol><p>实际上，在大多项目中使用端对端测试，都会给项目带来正向的、持续的作用。</p><h2 id="端对端测试可能面临的问题"><a href="#端对端测试可能面临的问题" class="headerlink" title="端对端测试可能面临的问题"></a>端对端测试可能面临的问题</h2><p>端对端测试面临的问题主要体现在测试环境和测试用例成本两个方面。</p><h3 id="测试环境问题"><a href="#测试环境问题" class="headerlink" title="测试环境问题"></a>测试环境问题</h3><p>对于测试环境配置方面，在使用容器化技术之前，通常都是本地使用 Windows 或者 Mac 开发，部署使用条件受限的 Linux 开发机器。</p><p>而端对端测试通常需要有 node 环境，并且需要下载一个浏览器和对应的控制工具（如 Puppeteer），以及需要成功把浏览器运行起来。</p><p>很多时候，虽然我们本地简单安装运行成功了，但是却由于种种原因无法成功在我们的开发机运行，这一点就劝退了很多团队。</p><p>本文提供的基于 K8s 容器化的方案，能够很好地解决这一问题。</p><h3 id="测试用例成本问题"><a href="#测试用例成本问题" class="headerlink" title="测试用例成本问题"></a>测试用例成本问题</h3><p>测试用例的成本也通常是端对端测试被诟病的一点，在一些团队中，大家通常会去寻找一些“录制”测试用例的工具，并且和测试岗位的同学“协作”完成，最终通常因为录制工具不完善、工具链维护成本太高等原因，变成一个失败的 KPI 项目。</p><p>在笔者看来，如果我们已经基于 Puppeteer 开发了一个相对完整的测试骨架，并且对通用问题已经封装了通用函数（如登录态的处理），实际上在对 Puppeteer 比较熟悉的情况下，写一个测试用例的成本还是非常低的，而且我们应该主要用端对端测试对重要的用例进行编写，即可能引起 P0 事故的用例，一些特别边界的、对用户体验影响微小的测试用例由人工定期检查，这样才能做到 ROI 最高。测试用例本身也应该由研发工程师或测试开发工程师进行编写，“录制”工具仅被用于辅助我们编写用例的工具，而不能成为我们的负担。</p><h2 id="基于-K8s-容器化运行"><a href="#基于-K8s-容器化运行" class="headerlink" title="基于 K8s 容器化运行"></a>基于 K8s 容器化运行</h2><p>接下来，我们对基于 K8s 容器化运行进行介绍。</p><p>这部分我们需要一个 K8s 环境，并且在此环境内可以访问我们的目标网站，对于本地开发而言，我们可以在自己的电脑上安装一个 docker 环境进行测试。</p><blockquote><p>实际上，端对端测试不会影响主业务流程，即使我们现在主业务没有使用 K8s，我们也可以独立部署一个简单环境用于端对端测试。</p></blockquote><p>我们的主流程如下：</p><ol><li>新建一个基于 Typescript 的 Node 项目，安装 Puppeteer 等依赖编写测试代码。</li><li>基于 <code>zenika/alpine-chrome:with-node</code> 定义一个 Dockerfile，将我们的测试代码一并打包成镜像。</li><li>本地直接通过 <code>docker build</code> 以及 <code>docker container run</code> 的方式运行镜像，进行验证（单次可能需要半分钟，不过当你开发过 Rust，你就会觉得这个时间并不算长，但能保证环境一致性）。</li><li>将完全版镜像推送到我们的内部镜像仓库，或者打成 tar 包。</li><li>利用 K8s cronjob 来设置定时任务，定时运行我们的端对端测试。</li></ol><p>借助网上的开源项目如 <a href="https://github.com/Zenika/alpine-chrome/blob/master/with-puppeteer/Dockerfile">alpine-chrome/with-puppeteer/</a>，我们已经可以比较方便地来修改测试，不过笔者还是做了一些整理，放到了 <a href="https://github.com/aircloud/easy-e2e">easy-e2e</a> 这个仓库，主要的一些修改如下：</p><ul><li>默认原示例是使用了 <code>--cap-add=SYS_ADMIN</code> 的方式来运行镜像，这种方式的问题在于，我们在部署的时候很可能由于安全策略限制被禁止这样部署（甚至还可能和运维人员扯皮），而在我们的端对端测试环境下，我们访问的网站一般都是我们自行开发的网站，相对来说可以比较信任，笔者改成了直接在代码中使用 <code>--no-sandbox</code> 选项，这样的好处是最小化部署的额外配置，从而更顺利地推动落地。</li><li>添加了 pnpm、Typescript 的使用，对脚本做了一些整理，可以让这个示例更接近一个我们实际开发维护的项目，而不仅仅是一个 demo。</li></ul><p>基于上文的示例仓库，我们已经完成上述 1-3 点，而镜像推送和 K8s 定时任务，实际上部署起来也非常简单，这部分由于通常需要一些认证授权配置，示例中没有给出实现。</p><h2 id="端对端测试的一些注意事项"><a href="#端对端测试的一些注意事项" class="headerlink" title="端对端测试的一些注意事项"></a>端对端测试的一些注意事项</h2><p>复杂的端对端测试通常会面临维护性问题，即我们的 dom 结构如果改变，需要修改端对端测试用例，这个没有办法完全避免，但是可以通过一些手段来尽可能地提高可维护性：</p><ul><li>对页面的主要模块增加 id，通过 id 辅助查找 dom 元素，避免出现太长的 dom 路径查询语句。</li><li>在端对端测试中将 DOM 交互和查询与验证逻辑分离，验证逻辑做到和 DOM 无关。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;前言：&lt;br&gt;日常开发中，如果你曾经遇到过类似问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个之前开发的、很久不维护的项目或页面，突然被告知无法访问或无法使用了。&lt;/li&gt;
&lt;li&gt;一些重数据的页面，用户反馈有的时候数据对不上，但是自己开发的时候明明测过没有</summary>
      
    
    
    
    
    <category term="测试" scheme="http://localhost:4000/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>关于 JupyterLab cell 输出保持问题的设计方案</title>
    <link href="http://localhost:4000/2022/09/16/%E5%85%B3%E4%BA%8EJupyterSession%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/"/>
    <id>http://localhost:4000/2022/09/16/%E5%85%B3%E4%BA%8EJupyterSession%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/</id>
    <published>2022-09-16T11:15:51.000Z</published>
    <updated>2023-10-02T14:15:46.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文试图尝试阐述目前 JupyterLab 当前存在的 cell 输出保持问题的原因，并且给出一个基于当前 Jupyter 架构的解决方案。</p><h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>这个问题，简单描述为就是当我们在 JupyterLab Notebook 中执行一个耗时代码，如果此时我们因为某些原因刷新或者关闭重新打开了页面，我们就永远无法继续跟踪输出了。</p><p>我们通过一个例子来更直观地感受：</p><p>JupyterLab 在 NodeBook 中运行如下的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; <span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;current: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/jupyter_cell1.png" alt="跟踪日志"></p><p>如果此时你强制刷新页面，就会发现标准输出丢失，并且这个时候没有办法再找到。</p><h2 id="该问题的社区讨论和成因概述"><a href="#该问题的社区讨论和成因概述" class="headerlink" title="该问题的社区讨论和成因概述"></a>该问题的社区讨论和成因概述</h2><blockquote><p>如果只关注解决方案，可以直接滚动至下文解决方案部分</p></blockquote><h3 id="社区现状"><a href="#社区现状" class="headerlink" title="社区现状"></a>社区现状</h3><ul><li>在 2015 年这个问题就被提出来了，不过因为它和当前 jupyter 的架构有所冲突，需要对 server 端进行巨大的重构，所以就一直搁置，<strong>官方至今未修复此问题</strong>。</li><li>社区一些曲折方案，但是所有方案<strong>都需要使用者代码改动或者安装额外插件</strong>，笔者对其中一些方案进行列举：<ul><li>有人提出使用 ipycache 这个插件，可以保存输出，不至于让输出丢失，但仍然不能监控进度，而且要写一些额外代码，相对来说还是会比较麻烦。</li><li>还有人提出使用 <code>%%capture var</code> 来捕获一些 stderr，通过 <code>var.show()</code> 来显示，同样的，这个也是只能等到执行完 cell 之后。</li><li>第三个类似的方案：<code>sys.stdout = open(&#39;my_log.log&#39;, &#39;w&#39;)</code></li></ul></li><li>目前 JupyterLab V4 版本正在进行 <a href="https://github.com/jupyterlab/jupyterlab/issues/5382">Real Time Collaboration</a> 功能的开发，涉及到很大的改动，<strong>在原本的计划中，会顺带把这个问题修复掉</strong>。<ul><li><em>V4 版本在 22 年 5月左右开始发布 alpha 版本，目前仍然处于 alpha 阶段，乐观来讲明年年初也许可以 Release 正式版本（P.S. 我们现在一般用的是 V3， 的 21 年 11月左右发布的一个较为稳定的版本）</em></li></ul></li><li>在 2022 年的 5 月 19 日，这个问题被移动到了 Jupyter 的<a href="https://github.com/jupyterlab/jupyterlab/projects/12#card-65141043">任务看板</a>之中，不过目前<strong>没有负责人</strong>。</li></ul><p>总之，解决这个问题的主要困境为：</p><ul><li>在现有架构上无法很好地解决，需要新增模块，在架构上做变更，而且需要改动 server 部分（和 notebook 共用），同时向前兼容。</li><li>需要对 Jupyter 以及其周边实现理解非常深刻，并且对 Jupyter 正在和将要进行的工作非常熟悉，特别是 RTC 部分，才有可能解决并将代码合入主干。<ul><li>而 RTC 又是一个非常复杂、暂时很难完全 release 的功能，所以如果基于 RTC 去设计解决方案，很可能你在一年内都无法上线 Jupyter 正式版</li></ul></li><li>解决该问题需要花费的时间较多，沉没成本高，所以很多有一些想法的研究者，也只是眼巴巴希望官方能解决。</li></ul><h2 id="解决方案概述"><a href="#解决方案概述" class="headerlink" title="解决方案概述"></a>解决方案概述</h2><p>我们这里经过权衡，设计出一套不依赖 RTC 功能解决该问题的方案。</p><p>我们主要需要改动一下几点：</p><ol><li><strong>修改 JupyterLab Workspace 机制，改成唯一 ID</strong></li><li><strong>修改 JupyterLab Notebook 连接 kernel 的 UUID 逻辑，改成非随机的 UUID</strong></li><li><strong>修改发消息的 msg ID，改为非随机的 UUID</strong></li><li><strong>新增恢复逻辑，根据 message 的 UUID 将输出写入到对应 cell</strong></li><li>[可选] Server 端保留更多输出内容</li></ol><p>改动的范围主要是 JupyterLab 前端 packages 下的各个模块，后端部分需配合做少量修改。</p><p>接下来我们依次详细说明以下改动</p><h3 id="1-Workspace-修改"><a href="#1-Workspace-修改" class="headerlink" title="1. Workspace 修改"></a>1. Workspace 修改</h3><p>JupyterLab 的 workspace 实际上就是你打开多个 JupyterLab 之后，URL 中 <code>/lab/workspaces/***</code> 后面的那一串，JupyterLab 会针对不同的 Workspace 存储不同的布局等信息，不过笔者认为，Jupyter 的 Workspace 还是有一定缺陷的，接下来会进行详细分析。</p><p><strong>在同一个浏览器里面：</strong></p><p>每当你打开一个 jupyter 页面，它会做这样几件事情：</p><ol><li>获取下当前自己的 workspace 名字，如果 url 里面有 workspace 参数就用 url 里面的，如果没有就用默认名字（第一个打开的页面一般是没有的），比如 <code>default</code></li><li>在 localstorage 里面写一个 <code>ping</code>，并 <code>window.addEventListener(&#39;storage&#39;)</code> 来接受其他页面的 <code>pong</code><ul><li>其他已经打开的同源 jupyter 页面，也会通过 <code>window.addEventListener(&#39;storage&#39;)</code> 监听 <code>ping</code> 并返回 <code>pong</code>，携带自己的 workspace 名字</li><li>这样，这个页面就知道当前有哪些页面打开了</li></ul></li><li>如果其他已经打开的页面里面有重名的 workspace，这个时候：<ul><li>它从 <code>abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789</code> 中随机取一个随机数，组成 <code>auto-随机数</code>, 放到 workspace 参数里面，<strong>重启整个页面</strong></li><li>重启页面之后，重新执行步骤 1</li></ul></li></ol><p>因此：</p><ul><li>除了第一个 jupyter 页面以外，其他的 Tab 打开都是需要刷新两遍的</li><li>并且随着冲撞的概率变高，当你打开的 Tab 越多，新开的 Tab 的刷新次数期望值越高，也就是说，你等待的时间越长。</li></ul><p>因为一共就 62 个随机数，假设所有的随机数用完了，会发生什么？</p><p><strong>是的，JupyterLab 会直接无限循环 Reload, 无法使用，经过实测，确实如此。</strong></p><p><strong>在不同的浏览器里面：</strong></p><p>他们完全互不知情，因此：</p><p>不同浏览器直接打开的第一个 workspace 都叫做 default，后续的更多 tab 是否冲突看运气。<br>当你在不同的浏览器 JupyterLab，并且在 JupyterLab 里面打开了一些东西，之后原来浏览器 Tab 刷新，就会被影响到了，<strong>这个问题在多用户集群场景下会更加显著。</strong></p><p>同时，JupyterLab 后端会把 workspace 配置持久化到文件中，<strong>不过自身没有配置文件清理逻辑</strong></p><p>所以，针对 Workspace 我们整体的改动为：</p><ul><li>去掉默认的 Workspace 逻辑。</li><li>Workspace 的 id 变成 uuid，保证大家即使不同浏览器访问也不一致。</li><li>添加 Workspace 配置数据的清理逻辑，定时清理很久没有在用的 Workspace 信息。</li></ul><h3 id="2-Notebook-kernel-uuid"><a href="#2-Notebook-kernel-uuid" class="headerlink" title="2. Notebook kernel uuid"></a>2. Notebook kernel uuid</h3><blockquote><p>这部分可以结合下文“扩展阅读”，来更加深入地了解。</p></blockquote><p>目前，当我们打开一个 Notebook 的时候，默认 Jupyter 就会新开一个 Kernel，然后前端 Notebook 通过建立 websocket(有一个叫做 <code>KernelConnection</code> 的类来管理 websocket) 来和 Kernel 通信。</p><p>同一个 Notebook，会随机生成一个 uuid，这个 uuid 是在 KernelConnection 管理类创建的时候生成的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">KernelConnection</span> <span class="keyword">implements</span> <span class="title class_">Kernel</span>.<span class="property">IKernelConnection</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Construct a kernel object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">options: Kernel.IKernelConnection.IOptions</span>) &#123;</span><br><span class="line">    <span class="comment">// 一般而言这里的 clientId 都是空</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_clientId</span> = options.<span class="property">clientId</span> ?? <span class="variable constant_">UUID</span>.<span class="title function_">uuid4</span>();</span><br><span class="line">    <span class="comment">// 其他逻辑...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然后对于非广播的消息（这里比如 kernel 的状态，它就是一个广播消息，而 python 代码块的具体执行，它是一个非广播消息，这一点更多也可以参考下文扩展阅读），是只会发送到这个 uuid 对应的 KernelConnection 客户端。</p><p>也因此，当目前刷新页面之后，<strong>这个 uuid 就变了</strong>，这个时候就无法对接到之前的非广播消息。</p><p>那么 JupyterLab 为什么不保持 uuid 不变呢，主要说法是：</p><ol><li>如果你打开了多个 Tab，它们使用相同的 uuid，这个必然会造成消息发送紊乱，实际上这样在建立连接的这步就会失败。</li><li>有的时候，客户端会短暂断网，这个时候对应 uuid 的 websocket 会断连，假设后面再连接上，不知道是新的页面还是当前的网络恢复了，后端不知道这个信息，因此会对设计 uuid 复用逻辑有所影响。</li></ol><p>所以，如果我们改变 uuid 的策略，需要在保证 Workspace 的唯一的前提下，设计连接 websocket 的 uuid 为 <strong><code>workspaceId - notebookId</code></strong></p><h3 id="3-Notebook-cell-uuid"><a href="#3-Notebook-cell-uuid" class="headerlink" title="3. Notebook cell uuid"></a>3. Notebook cell uuid</h3><p>在上一点我们更改了一个 Notebook 连接 kernel 的 uuid，但是对于其中一个 cell 的 uuid 还是随机的，这会导致即使 kernel 收到了消息，也无法得知这个消息是属于哪个 cell。</p><p>我们梳理下目前 cell 执行 python 代码的过程，接下来我们简化这个过程：</p><ol><li>当我们点击按钮，执行一个 cell 的代码的时候，Notebook 会构造这样的一条消息：</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> createMessage&lt;T <span class="keyword">extends</span> <span class="title class_">Message</span>&gt;(<span class="attr">options</span>: <span class="title class_">IOptions</span>&lt;T&gt;): T &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">buffers</span>: options.<span class="property">buffers</span> ?? [],</span><br><span class="line">    <span class="attr">channel</span>: options.<span class="property">channel</span>,</span><br><span class="line">    <span class="attr">content</span>: options.<span class="property">content</span>,</span><br><span class="line">    <span class="attr">header</span>: &#123;</span><br><span class="line">      <span class="attr">date</span>: <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">toISOString</span>(),</span><br><span class="line">      <span class="comment">// msgId 一般也是没有的</span></span><br><span class="line">      <span class="attr">msg_id</span>: options.<span class="property">msgId</span> ?? <span class="variable constant_">UUID</span>.<span class="title function_">uuid4</span>(),</span><br><span class="line">      <span class="attr">msg_type</span>: options.<span class="property">msgType</span>,</span><br><span class="line">      <span class="attr">session</span>: options.<span class="property">session</span>,</span><br><span class="line">      <span class="attr">username</span>: options.<span class="property">username</span> ?? <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      <span class="attr">version</span>: <span class="string">&#x27;5.2&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">metadata</span>: options.<span class="property">metadata</span> ?? &#123;&#125;,</span><br><span class="line">    <span class="attr">parent_header</span>: options.<span class="property">parentHeader</span> ?? &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">as</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>这条消息会调用上文提到的 <code>KernelConnection</code> 的实例方法 <code>sendShellMessage</code>，<code>sendShellMessage</code> 会把消息发送给后端，同时维护一个基于 <code>msgId</code> 的绑定关系。</p></li><li><p>后端 Kernel 执行完之后返回消息。返回的消息和发送的消息比较类似，比较重要的字段是 <code>parent_header</code>，<code>parent_header</code> 即发送的消息体中的 <code>header</code> 字段，其中存储 <code>msgId</code>。</p></li><li><p>Notebook 客户端收到消息后，通过 <code>parent_header</code> 中的 <code>msgId</code> 找到对应的 cell（这里实际上是执行一个 callback，callback 通过闭包捕获之前 cell 的相关引用），然后更新状态。</p></li></ol><p>也就是说，当我们更改 cell 的 msgId 计算方式的时候，实际上大多数时候上面的逻辑都是没有变化的，只是在刷新页面之后，因为这个时候之前的回调等逻辑是不存在的，我们需要手动找到这个 cell，然后把结果输出。</p><h3 id="4-新增恢复逻辑"><a href="#4-新增恢复逻辑" class="headerlink" title="4. 新增恢复逻辑"></a>4. 新增恢复逻辑</h3><p>基于上文我们 Workspace 和 uuid 的更新设计，我们已经可以把一个页面的一条消息对应到一个 cell 中，并且这里的绑定信息是可推断、可持久化、非随机的，也就是说，我们已经有了完成恢复功能的能力。</p><p>不过实际上要完成这个逻辑，还要加的内容非常多，Notebook cell 执行相关的逻辑本身状态判断较多且调用复杂，我们新加直接输出的逻辑不仅需要融入到现有的逻辑中，而且需要考虑各种边界情况，<strong>无异于做一次重构</strong>。</p><p>也因为第四点过于复杂，笔者并没有完全验证，只是依靠控制台输出做了一些分析验证可行性的工作。</p><h2 id="本文解决方案的不足之处"><a href="#本文解决方案的不足之处" class="headerlink" title="本文解决方案的不足之处"></a>本文解决方案的不足之处</h2><p>本文提供的解决方案，能够解决我们遇到的输出丢失问题，不过同时，它也是有一些副作用的，比如：</p><ul><li><strong>Notebook 修改名称逻辑会更复杂：</strong>因为设计上是将一个 Notebook 和它的 uuid 对应起来，实际上对于 Notebook 来说，它自身的 uuid 也就是它的路径名等信息，它并不存在一个类似 <code>文件 uuid</code> 的概念，所以当文件名称变了，这个 uuid 也会跟着变化，这里的方案可能是：<ul><li>当 kernel 繁忙的时候不允许改名，因为这个时候改名会导致 uuid 变化，这样输出就丢失了，并把这个信息提示给用户。（事实上，这类交互在软件设计中不难见到，比如在 macOS 中，一个文件在拷贝的过程中是不允许改名的，所以笔者觉得这个也是可以被接受的）。</li><li>或者在 jupyter server 记录文件的更名信息，这样当改名的时候，我们可以通过一些临时记录保证长链接不变（但这样会设计的比较复杂，不是很建议）。</li></ul></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>为了方便更加深入了解 JupyterLab Client-&gt;Kernel 的架构，我们补充一些扩展信息。</p><h3 id="当前-Jupyter-Notebook-Kernel-的架构模型"><a href="#当前-Jupyter-Notebook-Kernel-的架构模型" class="headerlink" title="当前 Jupyter Notebook-Kernel 的架构模型"></a>当前 Jupyter Notebook-Kernel 的架构模型</h3><p>当前的 Jupyter 的 Notebook-Kernel 是一个多对一的架构，也就是说，我们可以开多个页面连接到相同的一个 Kernel，同时每个页面都执行不同的 cell，它们是都可以正确的和输出对应起来的。</p><p><img src="/img/jupyter_frontend_kernel.webp"></p><p>同时，对于一些比如 kernel 状态的信息，是会广播给所有客户端的。</p><p>目前 Jupyter 通过 <a href="https://github.com/jupyter/jupyter_client">jupyter_client</a> 这个包来和 kernel 进行管理和通信，这个包虽然叫做 client，但是是在 server 端，使用的，主要是和 jupyter 的 kernel 通信。</p><p>默认使用的是 <a href="https://github.com/ipython/ipykernel">ipykernel</a></p><p>启动代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;/path/to/bin/python&#x27;, &#x27;-m&#x27;, &#x27;ipykernel_launcher&#x27;, &#x27;-f&#x27;, &#x27;/path/to/Jupyter/runtime/kernel-85259599-797f-4b21-b701-2a63c96fbe10.json&#x27;]</span><br></pre></td></tr></table></figure><p>kernel 文件中会存储通信端口等一些信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;shell_port&quot;</span><span class="punctuation">:</span> <span class="number">57748</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;iopub_port&quot;</span><span class="punctuation">:</span> <span class="number">57749</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stdin_port&quot;</span><span class="punctuation">:</span> <span class="number">57750</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;control_port&quot;</span><span class="punctuation">:</span> <span class="number">57752</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hb_port&quot;</span><span class="punctuation">:</span> <span class="number">57751</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ba04817a-be19696087459a6a772e6268&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;transport&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tcp&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;signature_scheme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hmac-sha256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kernel_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>jupyter_client 使用 zmq 来做和 kernel 之间的通信。</p><h3 id="其他链接"><a href="#其他链接" class="headerlink" title="其他链接"></a>其他链接</h3><ul><li><a href="https://github.com/jupyterlab/jupyterlab/issues/2833">Reconnect to running session: keeping output</a></li><li><a href="https://groups.google.com/g/jupyter">jupyter 邮件组</a></li><li><a href="https://github.com/jupyterlab/rtc">https://github.com/jupyterlab/rtc</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h2&gt;&lt;p&gt;本文试图尝试阐述目前 JupyterLab 当前存在的 cell 输出保持问题的原因，并且给出一个基于当前 Jupyter 架构的解决方案。</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://localhost:4000/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>读完 type-challenges，我总结了如下常用的内容</title>
    <link href="http://localhost:4000/2022/07/30/type-challenges/"/>
    <id>http://localhost:4000/2022/07/30/type-challenges/</id>
    <published>2022-07-30T07:39:38.000Z</published>
    <updated>2023-10-02T14:15:46.140Z</updated>
    
    <content type="html"><![CDATA[<p>近期用了一定时间通读了 <a href="https://github.com/type-challenges/type-challenges">type-challenges</a>，感慨 Typescript 也可以写的如此复杂之余，也出于以下几个原因，对题目做了整理，形成本文：</p><ul><li>type-challenges 整体题目较多，而且很多时候我们只是学习为主，并不是以“做题”为目的，这样我们在列表-问题-答案列表-答案详情中跳来跳去很麻烦，也很难甄别优质解答。</li><li>type-challenges 仓库中某些题目，实属偏门，可能对于大多数业务开发来说，永远也用不到，投入时间在这部分，ROI 就会非常低。</li><li>type-challenges 有些题目比较类似，但是却放到了不同的地方，甚至难度不同，笔者认为结合起来一起看可能更高效。</li></ul><p>因此，本文对笔者认为重要的、有业务使用场景或者可以给我们以很大启发的题目进行罗列和解析，同时规避了一些复杂度很高，但实际大多数人用不到的题目（比如 Typescript 实现 JSON 解析），对于普通的 Typescript 开发者而言，看完本文的题目就基本能够以一个比较小的代价掌握 type-challenges 中贴近日常开发和业务的部分。</p><blockquote><p>感谢 type-challenges 仓库的贡献者们</p></blockquote><h2 id="Typescript-内置工具函数"><a href="#Typescript-内置工具函数" class="headerlink" title="Typescript 内置工具函数"></a>Typescript 内置工具函数</h2><p>实际上，Typescript 自身除了定义类型以外，自己内置了很多非常有用的工具函数，这部分是我们日常 Typescript 开发应当必须掌握，信手拈来的，我建议如果对这部分不熟悉的话，先多读几遍这部分。</p><p>这部分内容，可以在<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">这里</a> 了解，也可以在自己的项目中，点进 <code>node_modules/typescript/lib/lib.es5.d.ts</code> 直接了解，注释比较详尽。</p><blockquote><p>实际上，type-challenges 的一部分简单和中等的题目就是实现这些内置工具函数的二次实现，这部分内容我在本文基本没有重复罗列，但是建议大家去阅读官方实现，一般来说也都比较短小，容易理解</p></blockquote><h2 id="type-challenges-部分重点题目"><a href="#type-challenges-部分重点题目" class="headerlink" title="type-challenges 部分重点题目"></a>type-challenges 部分重点题目</h2><h3 id="数组第一个元素"><a href="#数组第一个元素" class="headerlink" title="数组第一个元素"></a>数组第一个元素</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00014-easy-first/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arr1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> head1 = <span class="title class_">First</span>&lt;arr1&gt; <span class="comment">// expected to be &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">First</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [infer first, ...<span class="built_in">any</span>[]]</span><br><span class="line">  ? first</span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><p>除了本题目，还有许多其他类似的实现：：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组最后一个元素:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Last</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T <span class="keyword">extends</span> [...<span class="built_in">any</span>, infer L] ? L : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop：</span></span><br><span class="line"><span class="comment">// type arr1 = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span></span><br><span class="line"><span class="comment">// type re1 = Pop&lt;arr1&gt; // expected to be [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Pop</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> [...infer P, infer R] ? P : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push:</span></span><br><span class="line"><span class="comment">// type Result = Push&lt;[1, 2], &#x27;3&#x27;&gt; // [1, 2, &#x27;3&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Push</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [...T, U];</span><br><span class="line"></span><br><span class="line"><span class="comment">// UnShift:</span></span><br><span class="line"><span class="comment">// type Result = UnShift&lt;[1, 2], 0&gt; // [0, 1, 2,]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">UnShift</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], U&gt; = [U, ...T];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shift:</span></span><br><span class="line"><span class="comment">// type Result = Shift&lt;[3, 2, 1]&gt; // [2, 1]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Shift</span>&lt;T&gt; = T <span class="keyword">extends</span> [infer F,... infer R] ? R : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Concat：</span></span><br><span class="line"><span class="comment">// type Result = Concat &lt;[1], [2]&gt; // expected to be [1, 2]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Concat</span> &lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], V <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = [...T, ...V];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reverse:</span></span><br><span class="line"><span class="comment">// type b = Reverse&lt;[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]&gt; // [&#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Reverse</span>&lt;T&gt; = T <span class="keyword">extends</span> [infer <span class="title class_">Head</span>, ...infer <span class="title class_">Rest</span>] ? [...<span class="title class_">Reverse</span>&lt;<span class="title class_">Rest</span>&gt;, <span class="title class_">Head</span>] : T</span><br><span class="line"></span><br><span class="line"><span class="comment">// FilterOut：</span></span><br><span class="line"><span class="comment">// type Filtered = FilterOut&lt;[1, 2, null, 3], null&gt; // [1, 2, 3]</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Filtered</span> = <span class="title class_">FilterOut</span>&lt;[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">null</span>, <span class="number">3</span>], <span class="literal">null</span>&gt; <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">FilterOut</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[], F&gt; = </span><br><span class="line">  T <span class="keyword">extends</span> [infer <span class="title class_">First</span>, ...infer <span class="title class_">Rest</span>] </span><br><span class="line">    ? <span class="title class_">First</span> <span class="keyword">extends</span> F </span><br><span class="line">      ? <span class="title class_">FilterOut</span>&lt;<span class="title class_">Rest</span>, F&gt; </span><br><span class="line">      : [<span class="title class_">First</span>, ...<span class="title class_">FilterOut</span>&lt;<span class="title class_">Rest</span>, F&gt;] </span><br><span class="line">    : []</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li>通过 extends 加三目运算符，完成条件判断。</li><li>通过类似 <code>infer first, ...any[]</code> 或者 <code>[infer First, ...infer Rest]</code> 这种方式来展开数组类型。</li><li>另外我们还可以使用 <code>[...T, U]</code> 来扩充数组的类型定义。</li></ul><h3 id="Tuple-to-Union"><a href="#Tuple-to-Union" class="headerlink" title="Tuple to Union"></a>Tuple to Union</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Arr</span> = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = <span class="title class_">TupleToUnion</span>&lt;<span class="title class_">Arr</span>&gt; <span class="comment">// expected to be &#x27;1&#x27; | &#x27;2&#x27; | &#x27;3&#x27;</span></span><br></pre></td></tr></table></figure><p>实现比较简单：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TupleToUnion</span>&lt;T <span class="keyword">extends</span> <span class="built_in">any</span>[]&gt; = T[<span class="built_in">number</span>];</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li><code>T[number]</code> 这种语法可以比较方便地实现 Tuple to Union</li></ul><h3 id="Deep-Readonly"><a href="#Deep-Readonly" class="headerlink" title="Deep Readonly"></a>Deep Readonly</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.md#deep-readonly----">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> X = &#123; </span><br><span class="line">  <span class="attr">x</span>: &#123; </span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    <span class="attr">b</span>: <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">y</span>: <span class="string">&#x27;hey&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Expected</span> = &#123; </span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">x</span>: &#123; </span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">    <span class="keyword">readonly</span> <span class="attr">b</span>: <span class="string">&#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">y</span>: <span class="string">&#x27;hey&#x27;</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Todo</span> = <span class="title class_">DeepReadonly</span>&lt;X&gt; <span class="comment">// should be same as `Expected`</span></span><br></pre></td></tr></table></figure><p>实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">DeepReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [P <span class="keyword">in</span> keyof T]: keyof T[P] <span class="keyword">extends</span> <span class="built_in">never</span> ? T[P] : <span class="title class_">DeepReadonly</span>&lt;T[P]&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>技巧提示：</p><ul><li>通过 <code>keyof T[P] extends never</code> 这种方式判断是否有子属性，可以完成深度遍历</li></ul><h3 id="Merge-以及其他-interface-相关"><a href="#Merge-以及其他-interface-相关" class="headerlink" title="Merge 以及其他 interface 相关"></a>Merge 以及其他 interface 相关</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> foo = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> coo = &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">sex</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">Merge</span>&lt;foo,coo&gt;; <span class="comment">// expected to be &#123;name: string, age: number, sex: string&#125;</span></span><br></pre></td></tr></table></figure><p>Merge 的功能和 typescript 提供的很多内置功能函数很像，这个题目实现的方式很多，我这里给出一个比较简洁的方式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Merge</span>&lt;T, U&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> <span class="title class_">Exclude</span>&lt;keyof T, keyof U&gt;]: T[P];</span><br><span class="line">&#125; &amp; &#123;</span><br><span class="line">  [G <span class="keyword">in</span> keyof U]: U[G];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类似 Merge，我们在再给出一些其他的简单的类似 type 相关的操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Diff：选出两个类型中不同属性：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Diff</span>&lt;T, U&gt; = <span class="title class_">Omit</span>&lt;T &amp; U, keyof T &amp; keyof U&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PickByType：按照类型选择</span></span><br><span class="line"><span class="comment">// type OnlyBoolean = PickByType&lt;&#123;</span></span><br><span class="line"><span class="comment">//   name: string</span></span><br><span class="line"><span class="comment">//   count: number</span></span><br><span class="line"><span class="comment">//   isReadonly: boolean</span></span><br><span class="line"><span class="comment">//   isEnable: boolean</span></span><br><span class="line"><span class="comment">// &#125;, boolean&gt; // &#123; isReadonly: boolean; isEnable: boolean; &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">PickByType</span>&lt;T, U&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[K] <span class="keyword">extends</span> U ? K : <span class="built_in">never</span>]: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RequiredByKeys：按照 key 来设置成 Require</span></span><br><span class="line"><span class="comment">// interface User &#123;</span></span><br><span class="line"><span class="comment">//   name?: string</span></span><br><span class="line"><span class="comment">//   age?: number</span></span><br><span class="line"><span class="comment">//   address?: string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// type UserRequiredName = RequiredByKeys&lt;User, &#x27;name&#x27;&gt; // &#123; name: string; age?: number; address?: string &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RequiredByKeys</span>&lt;T, K = keyof T&gt; = <span class="title class_">SimpleMerge</span>&lt;</span><br><span class="line">  <span class="title class_">Partial</span>&lt;<span class="title class_">Pick</span>&lt;T, <span class="title class_">Exclude</span>&lt;keyof T, K&gt;&gt;&gt;,</span><br><span class="line">  <span class="title class_">Required</span>&lt;<span class="title class_">Pick</span>&lt;T, <span class="title class_">Extract</span>&lt;keyof T, K&gt;&gt;&gt;</span><br><span class="line">  <span class="comment">// **可以看一下 Required 的写法，能学到一点新的东西</span></span><br><span class="line">&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutable</span></span><br><span class="line"><span class="comment">// interface Todo &#123;</span></span><br><span class="line"><span class="comment">//   readonly title: string</span></span><br><span class="line"><span class="comment">//   readonly description: string</span></span><br><span class="line"><span class="comment">//   readonly completed: boolean</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// type MutableTodo = Mutable&lt;Todo&gt; // &#123; title: string; description: string; completed: boolean; &#125;</span></span><br><span class="line"><span class="comment">// your answers</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Mutable</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Required</span></span><br><span class="line"><span class="comment">// type I = GetRequired&lt;&#123; foo: number, bar?: string &#125;&gt; // expected to be &#123; foo: number &#125;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">GetRequired</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> <span class="title class_">Required</span>&lt;T&gt;[P] ? P : <span class="built_in">never</span>]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">RequiredKeys</span>&lt;T&gt; = keyof <span class="title class_">GetRequired</span>&lt;T&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get Optional</span></span><br><span class="line"><span class="comment">// type I = GetOptional&lt;&#123; foo: number, bar?: string &#125;&gt; // expected to be &#123; bar?: string &#125;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00059-hard-get-optional/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">GetOptional</span>&lt;T&gt; = &#123;</span><br><span class="line">  [P <span class="keyword">in</span> keyof T <span class="keyword">as</span> T[P] <span class="keyword">extends</span> <span class="title class_">Required</span>&lt;T&gt;[P] ? <span class="built_in">never</span> : P]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">OptionalKeys</span>&lt;T&gt; = keyof <span class="title class_">GetOptional</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>一些技巧提示：</p><ul><li>通过组合 Typescript 内置的功能函数，我们可以完成很多复杂的业务需求。</li><li>通过 <code>-readonly</code> 来减去修饰符。</li><li>通过 <code>[P in keyof T]-?: T[P];</code> 这种方式来减去可选修饰符（Typescript 内置的 Required 就是这么实现的）。</li><li>通过 <code>K in keyof T as T[K]</code> 获取一个属性的类型，结合 extends 做条件判断。</li></ul><h3 id="TrimLeft-以及字符串相关"><a href="#TrimLeft-以及字符串相关" class="headerlink" title="TrimLeft 以及字符串相关"></a>TrimLeft 以及字符串相关</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> trimed = <span class="title class_">TrimLeft</span>&lt;<span class="string">&#x27;  Hello World  &#x27;</span>&gt; <span class="comment">// expected to be &#x27;Hello World  &#x27;</span></span><br></pre></td></tr></table></figure><p>实际上字符串操作在 Typescript 中应该用的并不是很多，而这也是 Typescript 比较后面（4.0+）才逐渐完善的功能。<br>这个题目的解答：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Space</span> = <span class="string">&quot; &quot;</span> | <span class="string">&quot;\n&quot;</span> | <span class="string">&quot;\t&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">TrimLeft</span>&lt;S <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;Space&#125;</span><span class="subst">$&#123;infer Rest&#125;</span>`</span></span><br><span class="line">  ? <span class="title class_">TrimLeft</span>&lt;<span class="title class_">Rest</span>&gt;</span><br><span class="line">  : S;</span><br></pre></td></tr></table></figure><p>实际上，我们如果知道可以这样写，还可以实现很多的类似的方式，比如可以很方便地实现 <code>Trim</code> 和 <code>TrimRight</code> （由于相似度非常高，这两个不再罗列答案），以及 <code>Replace</code>、<code>ReplaceAll</code>、<code>DropChar</code> 等，甚至还可以比较方便地实现类型转换，如 <code>ParseInt</code>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Replace</span></span><br><span class="line"><span class="comment">// type replaced = Replace&lt;&#x27;types are fun!&#x27;, &#x27;fun&#x27;, &#x27;awesome&#x27;&gt; // expected to be &#x27;types are awesome!&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">Replace</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = <span class="title class_">From</span> <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Left&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;Right&#125;</span>`</span></span><br><span class="line">  : S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 近似 Replace，替换全部</span></span><br><span class="line"><span class="comment">// type replaced = ReplaceAll&lt;&#x27;t y p e s&#x27;, &#x27; &#x27;, &#x27;&#x27;&gt; // expected to be &#x27;types&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ReplaceAll</span>&lt;</span><br><span class="line">  S <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">From</span> <span class="keyword">extends</span> <span class="built_in">string</span>,</span><br><span class="line">  <span class="title class_">To</span> <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">&gt; = <span class="title class_">From</span> <span class="keyword">extends</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  ? S</span><br><span class="line">  : S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Left&#125;</span><span class="subst">$&#123;From&#125;</span><span class="subst">$&#123;infer Right&#125;</span>`</span></span><br><span class="line">  ? <span class="string">`<span class="subst">$&#123;Left&#125;</span><span class="subst">$&#123;To&#125;</span><span class="subst">$&#123;ReplaceAll&lt;<span class="string">`<span class="subst">$&#123;Right&#125;</span>`</span>, From, To&gt;&#125;</span>`</span></span><br><span class="line">  : S;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Drop Char</span></span><br><span class="line"><span class="comment">// 和上面的比较类似</span></span><br><span class="line"><span class="comment">// type Butterfly = DropChar&lt;&#x27; b u t t e r f l y ! &#x27;, &#x27; &#x27;&gt; // &#x27;butterfly!&#x27;</span></span><br><span class="line"><span class="comment">// https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/README.md</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">DropChar</span>&lt;S, C&gt; = S <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer H&#125;</span><span class="subst">$&#123;infer R&#125;</span>`</span></span><br><span class="line">  ? H <span class="keyword">extends</span> C</span><br><span class="line">    ? <span class="string">`<span class="subst">$&#123;DropChar&lt;R, C&gt;&#125;</span>`</span></span><br><span class="line">    : <span class="string">`<span class="subst">$&#123;H&#125;</span><span class="subst">$&#123;DropChar&lt;R, C&gt;&#125;</span>`</span></span><br><span class="line">  : <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseInt：字符串转数字：</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ParseInt</span>&lt;T <span class="keyword">extends</span> <span class="built_in">string</span>&gt; = T <span class="keyword">extends</span> <span class="string">`<span class="subst">$&#123;infer Digit <span class="keyword">extends</span> <span class="built_in">number</span>&#125;</span>`</span> ? <span class="title class_">Digit</span> : <span class="built_in">never</span></span><br></pre></td></tr></table></figure><p>另外，基于操作字符串的能力，我们还可以实现更多，比如：</p><ul><li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00531-medium-string-to-union/README.md">StringToUnion</a> 字符串转联合类型，<code>123</code> -&gt; <code>&quot;1&quot; | &quot;2&quot; | &quot;3&quot;</code></li><li><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00612-medium-kebabcase/README.md">KebabCase</a> 字符串格式转换，<code>FooBarBaz -&gt; foo-bar-baz</code></li></ul><p>等等，这些笔者没有列举具体实现，是因为认为大部分开发中用的还是不多的，如果你直接一眼就能想出方案，可能也不用去看了。</p><h3 id="Append-Argument"><a href="#Append-Argument" class="headerlink" title="Append Argument"></a>Append Argument</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Fn</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">AppendArgument</span>&lt;<span class="title class_">Fn</span>, <span class="built_in">boolean</span>&gt; </span><br><span class="line"><span class="comment">// expected be (a: number, b: string, x: boolean) =&gt; number</span></span><br></pre></td></tr></table></figure><p>这个例子可能会在我们日常开发中用到，而且可以让我们回顾如何操作函数类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppendArgument</span>&lt;<span class="title class_">Fn</span> <span class="keyword">extends</span> (...<span class="attr">args</span>: <span class="built_in">any</span>) =&gt; <span class="built_in">any</span>, A&gt; = <span class="title class_">Fn</span> <span class="keyword">extends</span> (</span><br><span class="line">  ...<span class="attr">args</span>: infer <span class="title class_">Args</span></span><br><span class="line">) =&gt; infer <span class="title class_">Res</span></span><br><span class="line">  ? <span class="function">(<span class="params">...arg: [...Args, A]</span>) =&gt;</span> <span class="title class_">Res</span></span><br><span class="line">  : <span class="built_in">never</span>;</span><br></pre></td></tr></table></figure><h3 id="Append-to-object"><a href="#Append-to-object" class="headerlink" title="Append to object"></a>Append to object</h3><p><a href="https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-append-to-object/README.md">原文地址</a></p><p>使用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Test</span> = &#123; <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">AppendToObject</span>&lt;<span class="title class_">Test</span>, <span class="string">&#x27;value&#x27;</span>, <span class="number">4</span>&gt; <span class="comment">// expected to be &#123; id: &#x27;1&#x27;, value:</span></span><br></pre></td></tr></table></figure><p>注意和 <code>Merge</code> 有所区别，这里是针对 <code>Object</code> 来操作</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">AppendToObject</span>&lt;T, U, V&gt; = T <span class="keyword">extends</span> <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">any</span>&gt;</span><br><span class="line">  ? U <span class="keyword">extends</span> <span class="built_in">string</span></span><br><span class="line">    ? &#123; [K <span class="keyword">in</span> keyof T | U]: K <span class="keyword">extends</span> U ? V : T[K] &#125;</span><br><span class="line">    : T</span><br><span class="line">  : T;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>Typescript 特性相对完备，基于此可以完成非常复杂的需求，甚至使用 <a href="https://github.com/ronami/HypeScript">Typescript 来编写一个 Typescript Checker</a>，不过笔者认为，对于时间精力有限的一般工作中的开发者来说，知道“可以这样做”，并且在适当的时候可以通过简单的资料查阅完成需求，这一点可能更重要。</p><p>经过权衡，本文中只列举了部分 <a href="https://github.com/type-challenges/type-challenges">type–challenges</a> 中的内容，如果你还想了解更多，不妨看看原 github 仓库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;近期用了一定时间通读了 &lt;a href=&quot;https://github.com/type-challenges/type-challenges&quot;&gt;type-challenges&lt;/a&gt;，感慨 Typescript 也可以写的如此复杂之余，也出于以下几个原因，对题目做了整理，</summary>
      
    
    
    
    
    <category term="Typescript" scheme="http://localhost:4000/tags/Typescript/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust 开发 python 模块</title>
    <link href="http://localhost:4000/2022/06/04/python%E8%B0%83%E7%94%A8Rust/"/>
    <id>http://localhost:4000/2022/06/04/python%E8%B0%83%E7%94%A8Rust/</id>
    <published>2022-06-04T09:34:05.000Z</published>
    <updated>2023-10-02T14:15:46.140Z</updated>
    
    <content type="html"><![CDATA[<p>关于 Rust 的基本介绍，我在之前的<a href="http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/">文章</a>有做过一些总结。</p><p>本篇文章我们关注如何在 python 中调用 Rust 开发的模块。</p><h2 id="Rust-FFI-的一般思路"><a href="#Rust-FFI-的一般思路" class="headerlink" title="Rust FFI 的一般思路"></a>Rust FFI 的一般思路</h2><p>Rust 可以编译出兼容 C ABI 的动态库或者静态库，Rust 调用其他语言，以及 Rust 被其他语言调用，基本都是通过 C ABI 来进行 FFI 调用。</p><p>所以我们可以看出，实际上 C++ 调用 Rust <em>并不是特别方便</em>，需要使用 Rust 提供的 C 接口，也因此没有办法使用 C++ 提供的类型，而 Rust 在导出接口的时候，也没有办法使用 Rust 的类型系统，需要转换成 C 类型。</p><p>大多数时候我们都会在这种场景下写一层 wrapper 和 converter，用来自动生成 FFI 层的一些胶水代码。</p><p>对于 Python 这类高级语言调用 Rust，基本也是类似的思路，我们可以简单总结为下图：</p><p><img src="/img/calling_rust_from_python_std_ffi_and_ctypes.png"></p><p>值得庆幸的是，对于 Python 调用 Rust，社区已经有非常多现成的成熟工具可以使用，基于这些工具，我们可以比较方便地专注于 Rust 实现逻辑本身，无需关注太多 FFI 和转换细节。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>一个比较方便的方法是使用 <a href="https://github.com/PyO3/pyo3">PyO3</a>，PyO3 不仅仅提供了 rust binding，也提供了创建 python 包的开箱即用的脚手架工具 <a href="https://github.com/PyO3/maturin">maturin</a>，使用 maturin 我们可以很方便地创建一个基于 rust 开发的 python 扩展模块。</p><p>我们这里整理一下官方文档中提供的最简单的方式，读者可以直接依次执行下面的 shell 脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> string_sum</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> string_sum</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 venv 的这一步不能省略，否则后续运行的时候会报错</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python -m venv .<span class="built_in">env</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">source</span> .<span class="built_in">env</span>/bin/activate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">pip install maturin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接使用 maturin 初始化项目即可，选择 pyo3，或者直接执行 maturin init --bindings pyo3</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">maturin init</span></span><br><span class="line">✔ 🤷 What kind of bindings to use? · pyo3</span><br><span class="line">  ✨ Done! New project created string_sum</span><br></pre></td></tr></table></figure><p>这个时候，我们可以得到一个简单的 Rust 项目，并且包含了一个示例调用，我们无需修改任何代码，可以直接执行下面的命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">maturin develop 会自动打包出一个 wheel 包，并且安装到当前的 venv 中</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">maturin develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; import string_sum</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; string_sum.sum_as_string(5, 20)</span></span><br><span class="line">&#x27;25&#x27;</span><br></pre></td></tr></table></figure><h2 id="进阶工具"><a href="#进阶工具" class="headerlink" title="进阶工具"></a>进阶工具</h2><p>接下来，我们介绍几个方便我们使用 Rust 开发 python 包的进阶工具或引导。</p><h3 id="setuptools-rust"><a href="#setuptools-rust" class="headerlink" title="setuptools-rust"></a>setuptools-rust</h3><p><a href="https://github.com/PyO3/setuptools-rust">setuptools-rust</a> 是一个 setuptools 的插件，让我们可以比较方便地编写使用 pyo3 开发的 rust python 包。</p><p>我们可以 clone 它的源代码，直接使用它提供的示例，参考如下命令测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> examples/rust_with_cffi</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python ./setup.py develop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python</span></span><br><span class="line">Python 3.9.7 (default, Sep  3 2021, 12:37:55)</span><br><span class="line">[Clang 12.0.5 (clang-1205.0.22.9)] on darwin</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; from rust_with_cffi import rust</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; rust.rust_func()</span></span><br><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="dict-derive"><a href="#dict-derive" class="headerlink" title="dict-derive"></a>dict-derive</h3><p>这个 rust 库提供了 FromPyObject 和 IntoPyObject 两个宏，使用这两个宏，我们可以很方便地进行 python dict 结构和 Rust 结构体的转换。</p><p>例如我们声明这样一个结构体：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(FromPyObject, IntoPyObject)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> name: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> email: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> age: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就直接可以在导出函数中这样使用了：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Requires FromPyObject to receive a struct as an argument</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_contact_info</span>(user: User) <span class="punctuation">-&gt;</span> PyResult&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(<span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; - &#123;&#125;&quot;</span>, user.name, user.email))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Requires IntoPyObject to return a struct</span></span><br><span class="line"><span class="meta">#[pyfunction]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">get_default_user</span>() <span class="punctuation">-&gt;</span> PyResult&lt;User&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(User &#123;</span><br><span class="line">        name: <span class="string">&quot;Default&quot;</span>.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">        email: <span class="string">&quot;default@user.com&quot;</span>.<span class="title function_ invoke__">to_owned</span>(),</span><br><span class="line">        age: <span class="number">27</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过宏展开可以发现，这两个宏所做的事情就是分别将 <code>pyo3::types::PyDict</code> 转换成 Rust 结构体和将 Rust 结构体转换成 <code>pyo3::types::PyDict</code>。</p><p>整体宏展开的代码不多，还是比较方便阅读的。</p><h3 id="rust-numpy"><a href="#rust-numpy" class="headerlink" title="rust-numpy"></a>rust-numpy</h3><p><a href="https://github.com/PyO3/rust-numpy">rust-numpy</a> 是一个 rust 版本的 numpy C ABI 封装，使用这个库我们可以在 Rust 中调用 numpy</p><p>接下来我们运行该库的示例代码。</p><p>我们需要先安装 nox，nox 是一个 python 自动化任务工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">python3 -m pip install nox</span></span><br></pre></td></tr></table></figure><p>之后我们进入到命令行直接执行即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> examples/simple</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nox</span></span><br></pre></td></tr></table></figure><p>顺利的情况下，我们可以看到它会输出测试成功：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tests/test_ext.py .....                                                                                                                                       [<span class="number">100</span>%]</span><br><span class="line"></span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span> <span class="number">5</span> passed in <span class="number">0.32</span>s <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line">nox &gt; Session tests was successful.</span><br></pre></td></tr></table></figure><h3 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h3><p>在 Rust 中并没有直接和 python 中的 pandas 包对标的诸如 pandas-rs 包。</p><p>不过 Rust 标准库本身也提供了非常多的数据处理函数如筛选、过滤等，我们可以自己手写代码完成大部分 pandas 的工作。</p><p>在<a href="https://able.bio/haixuanTao/data-manipulation-pandas-vs-rust--1d70e7fc">这篇文章</a>中，作者使用了大约 160,000行/ 130列，总大小为 150Mb 的数据， 分别使用 Rust 和 Pandas 处理并测试，我们可以看到提升还是比较显著的：</p><table><thead><tr><th></th><th>Time(s)</th><th>Mem Usage(Gb)</th></tr></thead><tbody><tr><td>Pandas</td><td>3.0s</td><td>2.5Gb</td></tr><tr><td>Rust</td><td>1.6s 🔥 -50%</td><td>1.7Gb 🔥 -32%</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>pyo3 的 README 里面还列举了一些其他的工具库，使用起来相对比较简单，这里就不做单独介绍了。</p><ul><li><a href="https://github.com/vorner/pyo3-log">pyo3-log</a>：在 Rust 中使用 python 的 logging 库。</li><li><a href="https://github.com/PyO3/pyo3-built">pyo3-built</a>：可以在编译 rust 的 python 模块的时候写入一些构建信息，如 rust 版本等。</li><li><a href="https://github.com/awestlake87/pyo3-asyncio">pyo3-asyncio</a>：python asyio 的 Rust binding，可以将 python 的 async 转换成 Rust 的 features。</li><li><a href="https://github.com/mityax/rustimport">rustimport</a>：可以在 python 中直接引入 rust 代码，但因为引入的时候需要编译，笔者不是很建议在生产环境中直接使用。</li></ul><hr><p>虽然上面介绍了这么多工具，但是笔者认为，在实际使用中，还是远远不够的，我们应该还会结合业务，寻找和造出更多轮子，这部分工作就有待我们进一步开拓了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于 Rust 的基本介绍，我在之前的&lt;a href=&quot;http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%</summary>
      
    
    
    
    
    <category term="Rust" scheme="http://localhost:4000/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>基于 Container 架构的多框架前端应用</title>
    <link href="http://localhost:4000/2022/05/25/%E5%9F%BA%E4%BA%8Econtainer%E6%9E%B6%E6%9E%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/"/>
    <id>http://localhost:4000/2022/05/25/%E5%9F%BA%E4%BA%8Econtainer%E6%9E%B6%E6%9E%84%E7%9A%84%E5%89%8D%E7%AB%AF%E5%BA%94%E7%94%A8/</id>
    <published>2022-05-25T14:17:41.000Z</published>
    <updated>2023-10-02T14:15:46.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>本文提供一种用于构建多框架前端项目的思路，目前还尚未完整编写代码验证其可行性。</p><p>这种思路有些类似于<em>微前端</em>，实际上对于微前端来讲的话，社区已经有了 <a href="https://single-spa.js.org/">single-spa</a> 和基于其构建的 <a href="https://qiankun.umijs.org/zh/guide/tutorial">qiankun</a> 等若干方案。</p><p>这些框架都很优秀，也经过了不少生产项目的验证，能够在很大程度上满足微前端的需求。</p><p>但我个人觉得，对于一个团队规模不是很大，但是又存在不同技术栈的团队来说，直接使用这类微前端框架，会有一些负担，这主要体现在：</p><ol><li>各个微前端应用虽然可以互相调用，但是调用方式有限，对于复杂的内容比如通用 UI 模块的共享比较困难。</li><li>通常情况下，基座应用不够强大，一定程度上会加剧开发的独立性，不利于代码复用和共享。</li><li>原则上，<strong>对于小团队而言，我强烈建议统一成技术栈为 React 或者 Vue，没有任何道理可以支撑同时维护两套技术栈，但是如果想尝试一些新技术栈，可以在初期采用下述方案</strong>。</li></ol><p>我提出一种 Container 架构的前端应用，它可能应用在以下几个场景中：</p><ol><li>比如你想使用新的框架开发部分模块，例如使用 SolidJS 开发部分 React 项目中的组件，甚至使用 Rust 开发部分模块，用来做项目的实验性尝试。</li><li>出于团队人员技术栈的原因，需要 React 和 Vue 混合开发。</li><li>新的项目使用了 React，而旧的项目使用了 Vue，并且需要在短时间内把旧的项目放到新的项目中去使用。</li></ol><p>Container 架构的主要目的在于：</p><ol><li>增强基座项目的重要程度，从而做到尽可能更多地服用基础建设。</li><li>不仅模块本身可以用不同的框架编写，基座本身也可以被替换成不同的环境，例如：纯页面环境、定制化的 jupyter 环境、electron 环境。</li><li>可以让我们比较方便地进行部分模块先行升级，部分模块使用更高性能的技术栈开发同时尽可能多的复用现有基架。</li></ol><p>也就是说，<em>如果我们想换个语言开发，就新加一个模块就行，如果我们想换个地方运行，就新加一种基座就行</em>。</p><p>从而实现了双向自由度。</p><p>同时，它牺牲了一些内容：</p><ol><li>模块由于对基座项目的依赖性比较大，通常难以独立部署。</li></ol><h2 id="核心架构图"><a href="#核心架构图" class="headerlink" title="核心架构图"></a>核心架构图</h2><p>核心围绕一套 Container Abstract API 来展开。</p><p><img src="/img/absapp.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">node WebApp</span><br><span class="line">node JupyterApp</span><br><span class="line">node ElectronApp</span><br><span class="line">node BaseApp</span><br><span class="line">artifact ContainerAbstractAPI</span><br><span class="line">node ReactModule1</span><br><span class="line">node ReactModule2</span><br><span class="line">node VueModule</span><br><span class="line">node SolidModule</span><br><span class="line">WebApp .. BaseApp : 继承</span><br><span class="line">JupyterApp .. BaseApp : 继承</span><br><span class="line">ElectronApp .. BaseApp : 继承</span><br><span class="line">BaseApp .. ContainerAbstractAPI: 提供</span><br><span class="line">ContainerAbstractAPI .. ReactModule1 : 依赖</span><br><span class="line">ContainerAbstractAPI .. ReactModule2 : 依赖</span><br><span class="line">ContainerAbstractAPI .. VueModule : 依赖</span><br><span class="line">ContainerAbstractAPI .. SolidModule : 依赖</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure><p>真正应用部署的时候，选取一个 App，以及几个对应的 Module，就可以组合出我们的一套需要的项目。</p><p>针对这一套架构，对于通用的部分，我们尽可能地实现在 BaseApp 里面。</p><p>BaseApp 应该是比较少量的，一个团队中甚至只有一个，它可能会用到一些组件库或者框架，这些都可以的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于这套架构的一个示例代码实现，我会在后续文章中给出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概念介绍&quot;&gt;&lt;a href=&quot;#概念介绍&quot; class=&quot;headerlink&quot; title=&quot;概念介绍&quot;&gt;&lt;/a&gt;概念介绍&lt;/h2&gt;&lt;p&gt;本文提供一种用于构建多框架前端项目的思路，目前还尚未完整编写代码验证其可行性。&lt;/p&gt;
&lt;p&gt;这种思路有些类似于&lt;em&gt;微前</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://localhost:4000/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>我们应该如何进行 Code Review ?</title>
    <link href="http://localhost:4000/2022/04/25/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
    <id>http://localhost:4000/2022/04/25/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</id>
    <published>2022-04-25T12:35:00.000Z</published>
    <updated>2023-10-02T14:15:46.141Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。</p><p>这里的一个原因在于，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏掉一些 Review 的要点，甚至可能会感到无所适从。本文希望，针对一些非场景化的内容，整理出一些较为普适的一些原则，从而帮助 Reviewer（以及开发者本身）解决一些通用的问题。</p><h2 id="格式与规范"><a href="#格式与规范" class="headerlink" title="格式与规范"></a>格式与规范</h2><p>原则上，这部分内容不应该在 Review 的时候去处理，我们应该配置代码格式规范工具，在提交代码前或者 MR 的 CI 流水线中做这个事情。</p><p>这里对于不同类型的语言，大多社区都有现成的方案，不过多赘述，如果你在代码 Review 的时候还在纠结于格式和规范，那么现在就去配置好对应的工具。</p><h2 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h2><p>这里的稳定性，指的是我们程序在运行阶段的稳定性，以及当出现错误，我们能够第一时间发现。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>关于这里，最常见的一种代码是：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (some<span class="number">_</span>error<span class="number">_</span><span class="keyword">case</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种类似的代码，虽然看似兜底兜住了错误，但是并没有日志输出，也没有更多的提示，长久之后很可能会形成暗坑。</p><p>对于这种代码我们应该思考：</p><ul><li>是否应该打一个错误日志，提供一些上下文信息。</li><li>是否应该增加异常上报，让我们优化这种问题。</li><li>是否需要将这个错误信息返回给调用方或者调用端。</li><li>用户层面是否需要感知此信息，如果需要，方法是什么。</li></ul><p>另外还有一种比较常见的是异常，包括代码运行抛出的异常和我们自己捕获/抛出的异常：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (some_error_case) &#123;</span><br><span class="line">    throw new <span class="built_in">Error</span>(&#x27;some error&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    <span class="built_in">error_call</span>()</span><br><span class="line">&#125; <span class="built_in">catch</span>(e) &#123;</span><br><span class="line">    <span class="built_in">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这类异常的处理逻辑，和上面的异常条件逻辑比较类似，我们应该同样思考上述四点。</p><h2 id="保护用户隐私"><a href="#保护用户隐私" class="headerlink" title="保护用户隐私"></a>保护用户隐私</h2><p>隐私通常涉及到法律合规，因此可能是最重要的一环。</p><h3 id="用户的隐私不可泄漏"><a href="#用户的隐私不可泄漏" class="headerlink" title="用户的隐私不可泄漏"></a>用户的隐私不可泄漏</h3><ul><li>比如在开发功能打日志的时候，我们应该不能泄漏用户的隐私，例如用户的自定义信息、聊天信息等。</li></ul><p>这一部分建议在团队内部形成一个统一的规范文档，在开发和 Review 的过程中，大家都可以以此为依据。</p><h3 id="自己的隐私不可泄漏"><a href="#自己的隐私不可泄漏" class="headerlink" title="自己的隐私不可泄漏"></a>自己的隐私不可泄漏</h3><p>很多时候，我们虽然注意到了用户的隐私，但是<strong>自己的隐私</strong>却没有注意，这里主要是我们的一些 appKey、密钥等内容。无论是在以下哪些场景，我们都需要格外注意：</p><ul><li>对产物进行二次分发，例如分发到内部或外部 npm、github 以及其他团队，特别是外网可访问的情况更需要注意。</li><li>直接给到用户使用，例如在 Web 环境使用，或者打包到桌面端应用，尽量避免用户直接接触到这些内容。</li></ul><h2 id="可读性-维护性"><a href="#可读性-维护性" class="headerlink" title="可读性/维护性"></a>可读性/维护性</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><p>代码中函数和变量的命名，是可读性中比较重要的一个关注点。</p><p>关于如何命名，实际上很多架构书籍也都会额外列出一章来讲，在这里我不想过多进行赘述。不过一般来说，我们的命名应当清晰易懂，避免出现没有实际意义的含糊的变量名。</p><h3 id="代码提交的注释"><a href="#代码提交的注释" class="headerlink" title="代码提交的注释"></a>代码提交的注释</h3><ul><li><p>对于 bug fix：很多时候我们是在处理一个边界问题，或者某种兜底，这个时候 fix 的代码可能比较难以理解，在这种情况下我们最好是写明注释，如果有相关的文档和 bug 单，我们也可以一并贴到注释中。另外，如果我们的 bug fix 是一个临时方案，请在代码中写明 <strong>TODO</strong>，来提醒自己和别人这个地方后续还会继续更改。</p></li><li><p>对于新功能添加：一般我们需要在关键入口处写明功能的说明文档链接、完善相关关键路径的注释，同时删除功能开发中的冗余代码：例如我们在开发过程中测试用到但是最终却没有用到的大段注释掉的代码，以及大段的注释和 TODO，我们都需要在最终提交的时候<strong>删除掉</strong>，如果需要找回建议使用 git 的能力，可以适当进行注释备注。</p></li><li><p>另外，对于注释来说，<strong>禁止出现</strong>模糊的词汇，例如 <strong><code>感觉</code>，<code>好像</code>，<code>大概</code></strong> 等这种模糊的词汇，而是要培养自己严谨的意识，已经提交的代码必须有严格的佐证。</p></li></ul><h3 id="日志可读性"><a href="#日志可读性" class="headerlink" title="日志可读性"></a>日志可读性</h3><p>大多数项目的问题定位非常依赖日志。</p><p>对于日志，我们应该有如下几个约束：</p><ul><li>避免太多太长的内容，无论日志是以何种方式存储，规模上去之后的消耗都非常可观。</li><li>适当使用简写，但是避免完全不知所云，应该符合普遍约定。</li></ul><h3 id="代码的通用性"><a href="#代码的通用性" class="headerlink" title="代码的通用性"></a>代码的通用性</h3><p>当我们提交一个功能，或者修复一个问题的时候，很多时候我们只是从这个问题的角度护发，但是并没有从全局的角度出发，例如：</p><ul><li>当我们新增一个上报的时候，有没有考虑把整个上报聚合到一起，或者架构上支持更方便的上报能力？</li><li>当我们新增一个通用能力的时候，有没有考虑到其他模块或项目也可能有类似需求，我们是否可以将其单独抽离成一个独立的包进行分发？</li><li>当我们遇到一个问题有多种修复方案的时候，有没有综合考虑，哪一种方案对后续维护的同学更加友好（比如，最好是高内聚、低耦合的设计）？</li></ul><p>这里的大体原则，就是我们需要从整体性的角度出发，不断地迭代让整个架构更加夯实，而不是出个问题贴一个创可贴，新增功能又贴一个创可贴。</p><h3 id="配置化"><a href="#配置化" class="headerlink" title="配置化"></a>配置化</h3><p>这里的配置化，比较典型的比如是：多语言文案、项目 Settings 配置等。</p><ul><li>一般来说，配置化的内容最好是走云端下发。</li><li>如果不具备云端下发的环境，或者我们的配置<strong>比较敏感不适合直接下发</strong>，可以考虑在代码中创建配置文件的方式。</li></ul><p>如果我们在 Review 中发现有可以配置化的内容但是却直接写死在代码里面了，应当需要提出质疑。</p><h3 id="代码精简"><a href="#代码精简" class="headerlink" title="代码精简"></a>代码精简</h3><p>代码精简对后期的可维护性是非常重要的，代码精简的一个比价有效的办法就是充分理解业务，写出精简不多余的代码，不过这一点在 MR 中可能会比较难进行 Review，因为一般来说提交代码的同学本身已经是对这部分业务是理解的最透彻的。</p><p>但是有一点代码的 Reviewer 会比较容易判断，如果我们提交的代码里面有<strong>两处以上超过三行的极其相似的代码</strong>，我们就应当重新审视是否可以进行一定程度的抽离，建议不要由于一时的效率允许不符合规范的代码合入，这些在后期都可能演化成代码屎山。</p><p>例如，笔者对于 Rust 代码精简的一些建议：</p><ul><li>避免任何一次多余的 Clone。</li><li>文件头部引用中去除没有必要的引用。</li><li>避免多余的日志，同时避免在日志里面加太长的前缀内容（有的时候一行日志里面有多半都是元信息，而且这些元信息还是有所重复的）。</li><li>避免多余的 pub，应该有一个理念就是默认的内容不要 pub 出去，就像 c++ 的成员方法默认是 private 一样。</li><li>重复代码使用宏来替代。</li></ul><h2 id="重视性能"><a href="#重视性能" class="headerlink" title="重视性能"></a>重视性能</h2><h3 id="防止泄漏"><a href="#防止泄漏" class="headerlink" title="防止泄漏"></a>防止泄漏</h3><p>在考察性能之前，我们需要保证自己的代码没有泄漏，因为泄漏造成的恶劣性通常比性能差更严重，而且通常需要更长的时间来排查。</p><p>这里主要的检查点可以是：</p><ul><li>addListener 之后是否及时释放了。</li><li>setInterval/setTimeout 等定时器调用是否存在多次调用的可能性，以及是否可能无法释放。</li><li>分配在堆上的内存是否释放了。</li><li>是否有 detach dom 泄漏。</li></ul><h3 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h3><p>这一点如果是前端开发，一般没有机会遇到，但如果你用 rust、c++ 等语言，都很有可能出现死锁的风险（严格来说，死锁并不能直接归类到性能）。</p><p>对于死锁的防止，我建议团队内的基础设施部分先配置好死锁检测和上报机制（例如 parking_lot 提供了死锁检查的能力）。</p><p>一些死锁相关的 Review 建议：</p><ul><li>用到锁的地方，尽可能通过工具函数进行封装，类似 getter 和 setter，增加原子性，减少调用代码直接解锁的场景。</li><li>锁的粒度不应该太大，<strong>我们应该是对数据进行加锁，而不是对过程进行加锁</strong>，锁粒度过大很容易出现死锁的风险。</li><li>在函数脱离控制权之前，例如准备开始调用到其他外部函数了，这个时候最好把持有的锁都释放掉，防止外部函数再次用到造成锁重入。</li></ul><h3 id="性能报告"><a href="#性能报告" class="headerlink" title="性能报告"></a>性能报告</h3><p>关于这一部分，也建议团队基建先行，有一个比较标准的性能测试方法，这样大家在做性能测试的时候，不会那么有压力。比较反对的一种方式就是团队内部不同成员都有自己的一套性能测试方法，这样有些新同学缺乏必要的上下文，自然不了解如何去做性能测试。</p><p>一般来说，我们涉及到比较大的功能都要进行一些性能报告，相关的指标可以是：</p><ul><li>整体包体积的增加幅度。</li><li>初始化响应速度的变化。</li><li>运行该功能一段时间的 CPU 消耗。</li><li>运行该功能一段时间的 内存 消耗。</li><li>运行该功能较长时间的 CPU/内存 消耗。</li></ul><p>不过，具体这一部分还是建议团队内部根据项目的实际情况有一个统一的标准，并且将性能测试方法标准化，而不要成为一个负担。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>在兼容性这方面，无论是 web 开发还是桌面客户端开发，都需要重点关注，这里其实细分为两个维度：</p><ul><li>版本支持，例如我们可能会实现约定好支持到 Chrome 的哪个版本（针对 web）或者 macOS 的哪个版本（针对 macOS 桌面端），并且如果提交涉及到兼容性改动需要重点测试所支持的最低版本。</li><li>异常情况支持，这一点可能大多数时候都会被大家忽略，这里举一个例子就是 webgl 的支持，实际上，虽然大多数时候浏览器已经支持到了 webgl，但是仍然有不少场景，webgl 会初始化失败，这个原因可能和用户的硬件比如系统显卡有关，如果我们的项目只有 webgl 实现，我们需要考虑是否放弃 webgl 初始化失败的场景（从商业化的角度，一般来说都是希望不要放弃），或者说为此增加软渲染降级。</li></ul><p>所以，在 Code Review 环节，针对可能出现兼容性风险的地方，我们需要确认是否已经进行了兼容性测试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。&lt;/p&gt;
&lt;p&gt;这里的一个原因在于，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏</summary>
      
    
    
    
    
    <category term="编程综合" scheme="http://localhost:4000/tags/%E7%BC%96%E7%A8%8B%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《代码整洁之道-Clean Code》读书笔记</title>
    <link href="http://localhost:4000/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://localhost:4000/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</id>
    <published>2022-02-27T05:21:39.000Z</published>
    <updated>2023-10-02T14:15:46.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><p>《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看起来像某种特别在意他的人写的，几乎没有改进的余地，代码的作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给的代码——全心投入某人留给你的代码。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>这本书关于函数的介绍和其他架构书差不多，主要就是两个点：1. 短小，2. 抽象层次一致性。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>毫无疑问，注释是代码中的坏味道。</p><p>对于一部分注释，我们可以使用类似 4.4.8 这种变量的方式，通过新增两个变量，来解释我们的内容。<br>那种生成的注释和我们注释掉的代码，我的建议是：不要留。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>相关函数：按照本书的说明，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。我自己之前的习惯是调用者在被调用者的下面，目前又思考了一下，像作者这样组织，可能可读性反而更高。</p><blockquote><p>因为这样设计可以像报纸一样，最重要的概念先出现，并且希望以包括最小的细节表述他们，期望底层的细节后出现。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>使用异常而非返回码</strong>： 在 《代码精进之路》的读书笔记中，也提及了类似的思路，这个书里面又提到了使用异常而非返回码这一点，并且给出了一个新的理由，返回码意味着我们需要立即处理，这个步骤可能很容易被遗忘，而且会让我们的代码变得比较乱。</p><p>关于返回 null 值：有的时候，我们在数据处理中出现问题，可能会返回一个 null 或者 undefined。但是我建议相对于此，我们更应该直接抛出异常，返回 null 值意味着依赖调用者来做空检查，而且你不知道这个 null 究竟什么时候才会引发错误，这样会有较高的不稳定性。</p><h2 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h2><p>对于类的组织中，属性顺序的一个建议：依次是公共静态常量、私有静态变量、公共函数、私有函数。</p><p><strong>类的权责</strong>：对于一个类来说，我们不希望它被定义的太长，当然这个不能单纯地使用代码行数来判断，我们应该使用类的权责来判断，当一个类的名称越含糊，该类越有可能拥有更多权责，比如它的名称包含了诸如 Processor、Manager 或 Super，那么这种现象往往说明有不恰当的权责聚集的情况出现。</p><p><strong>如何把类拆的短小</strong>：我给出一个切实可行的办法，可以先从类的复杂函数入手，我们在把函数拆分的过程中，发现某些部分拆分成函数之后会传递大量的参数给它，否则很难拆分，那么传递给它这个函数的参数就可以被整合进新的小类的实体变量，这样我们就无需传递参数，同时也完成了拆分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整洁代码&quot;&gt;&lt;a href=&quot;#整洁代码&quot; class=&quot;headerlink&quot; title=&quot;整洁代码&quot;&gt;&lt;/a&gt;整洁代码&lt;/h2&gt;&lt;p&gt;《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://localhost:4000/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 fst-json 自动生成更快的 json 序列化方法</title>
    <link href="http://localhost:4000/2022/02/11/fst-json/"/>
    <id>http://localhost:4000/2022/02/11/fst-json/</id>
    <published>2022-02-11T10:45:54.000Z</published>
    <updated>2023-10-02T14:15:46.140Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。<br>其目的是利用现有的资源（开发过程编写的 Typescript 文件），在编译和开发阶段尽可能提高运行时性能，同时这个过程并没有额外的开发负担。</p></blockquote><p>github: <a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/466572196">https://zhuanlan.zhihu.com/p/466572196</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于 JSON schema 这个概念是由 fastify 引入，我们先对此进行介绍。</p><p><a href="https://github.com/fastify/fastify">fastify</a> 是一个高性能 Node.JS 服务端框架，其特点就是高性能，而之所以高性能主要的原因就是它引入了 JSON schema，通过对参数增加约束，来获得更快的序列化速度。</p><p>同时，fastify 也开源了一个独立的 json 序列化库 <a href="https://github.com/fastify/fast-json-stringify">fast-json-stringify</a>，可以在<strong>非 fastify 的项目中使用</strong>。</p><p>在 fastify 中，JSON schema 的大致写法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">        properties: &#123;</span><br><span class="line">          hello: &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fastify</span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    reply</span><br><span class="line">      .send(&#123; hello: <span class="string">&#x27;world&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>我们可以看出，这一套写法不仅会带来额外的学习成本，而且由于目前大多数项目开发都是采用 Typescript，这套定义也会和我们的 Typescript 定义有所重复。</p><p>事实上，虽然上面的示例代码比较短小，但是在实际的项目中，接口比较多的情况下，这些代码的开发量和额外的学习/维护成本还是不容小视的。</p><p>那么有没有可能直接使用 Typescript，而不用重新定义 JSON schema 呢？</p><p>答案是有的。</p><p><a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">fst-json</a> 就是这样一个工具，它可以通过复用我们在 Typescript 中定义的 schema，通过工具自动生成 fastify 需要的 schema，这样我们就无需额外维护 schema 定义了。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>接下来，我们简单介绍 fst-json 的使用方式，首先安装（全局或者安装到项目中）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i fst-json -g</span><br></pre></td></tr></table></figure><p>假设我们项目采用了 Typescript，事先已经有了 schema 文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">interface</span> <span class="symbol">HellWorld</span> &#123;</span><br><span class="line">  attr1: <span class="built_in">string</span>;</span><br><span class="line">  attr2: <span class="built_in">string</span>;</span><br><span class="line">  attr3?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目目录下新建 .fstconfig.js，用于声明配置，配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  sourceFiles: [</span><br><span class="line">    <span class="string">&#x27;./src/schema/*.ts&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  distFile: <span class="string">&quot;./src/schema-dist.ts&quot;</span>,</span><br><span class="line">  format: <span class="string">&#x27;fastify&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fst-json gen</span></span><br></pre></td></tr></table></figure><p>然后此时会生成一个 <code>src/schema-dist.ts</code>，这里会有自动生成的 JSON schema 定义，接下来我们在项目中可以同时使用 JSON schema 定义和我们之前定义好的 Typescript 类型：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="keyword">schemas</span> <span class="keyword">from</span> <span class="string">&#x27;./schema-dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; HellWorld  &#125; <span class="keyword">from</span> &quot;./schema&quot;;</span><br><span class="line"></span><br><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: <span class="keyword">schemas</span>.HellWorldSchema</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span></span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    let res: HellWorld = &#123;</span><br><span class="line">      attr1: <span class="string">&#x27;hello&#x27;</span>, </span><br><span class="line">      attr2: <span class="string">&#x27;world&#x27;</span>, </span><br><span class="line">      attr3: <span class="string">&#x27;optional&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply</span><br><span class="line">      .send(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然，fst-json 不仅仅可以在 fastify 中使用，也可以在任何其他需要 JSON 加速的地方使用，用法也都很简单，可以参考这个 <a href="https://github.com/aircloud/fst-json/tree/master/examples/helloworld">HelloWorld</a></p><h2 id="原理和优势"><a href="#原理和优势" class="headerlink" title="原理和优势"></a>原理和优势</h2><p>fst-json，实际上是通过对 Typescript 进行语法树解析，针对 export 导出的各种类型生成对应的 fast-json-stringify 的 JSON schema，所以运行速度和手写是没有区别的。因此，它不仅仅能完全使用 fast-json-stringify 的效率优势，除了减少重复开发量以外还有如下优点：</p><ul><li><strong>根据 schema 进行字段校验：</strong> 首先会进行 Tyepscript 语法校验，另外当缺失必须的属性（例如，当定义 interface 时没有被 <code>?</code> 修饰符修饰的属性缺失）的时候也会直接报错。</li><li><strong>过滤不需要的 schema 字段：</strong> 例如当把 Node.JS 当作 BFF 层的时候，可以严格按照 Typescript 的定义来返回字段，避免返回不需要的字段，从而避免上游服务的敏感字段被直接透传出去，也意味着从接口层面开始，真正做到 Fully Typed。</li><li><strong>更快的序列化速度：</strong> 根据 <a href="https://github.com/fastify/fast-json-stringify/issues">fast-json-stringify</a> 的测试，能达到接近 2 倍的 JSON 序列化速度。</li></ul><p>目前，fst-json 对常用的各类 interface、class、type 等类型定义都进行了支持，并且增加了各类 examples 和 90% 的覆盖率测试。</p><p>当然，由于 Typescript 的写法比较灵活。出于 JSON schema 本身的局限性，我们无法覆盖所有场景，所以也可以参考这里的<a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>，有针对性的对比较容易出问题的写法进行规避。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>fst-json 只是语法解析和生成工具，具体的运行时，实际上就是在使用 fast-json-stringify，也因此项目中需要安装 fast-json-stringify 依赖。</p><p>另外，针对 fast-json-stringify 的测试，在比较小的 payload 的情况下，它的速度是有优势的，当 payload 过大的时候，它的优势不再明显，甚至还不如 JSON.stringify。官方的描述是：</p><blockquote><p>fast-json-stringify is significantly faster than JSON.stringify() for small payloads.<br>Its performance advantage shrinks as your payload grows.</p></blockquote><p>不过事实上，这个时候你仍然可以使用 fst-json 做一些事情，例如笔者使用 fst-json 来做 bff 层对下游服务接口的持续集成兼容测试，在 Typescript 已经提前定义好了的情况下，每次测试的时候只需要请求依赖服务并且把响应字段序列化，如果没有报错并且字段序列化之后也没有变成 null（在比较复杂的接口定义中，如果个别属性定义类型和返回类型不一致，fast-json-stringify 是会直接转换成 null），就说明接口是没有变化的。可以有效避免依赖服务接口变化，却又没有及时同步到位造成暗坑的情况。</p><p>另外，其实目前 fast-json-stringify 生成序列化代码还是在运行时做的，这里的问题可能在于代码不透明，以及运行时开销和风险，笔者是希望将它的生成代码变成编译时去做，不过这样的话实际上有一点重复造轮子的错觉，所以目前还没有做这个事情。</p><hr><p>最后 <a href="https://github.com/aircloud/fst-json/">fst-json</a> 作为一个开源不久的小项目，肯定还有些需要优化和完善的地方，欢迎 star 支持和提出建议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。&lt;br&gt;其目的是利用现有的资源（开发过程编写的 Typescript 文件）</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://localhost:4000/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》与《代码整洁之道》-读书笔记</title>
    <link href="http://localhost:4000/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://localhost:4000/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-30T08:14:15.000Z</published>
    <updated>2023-10-02T14:15:46.141Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。</p><blockquote><p>《代码整洁之道-程序员的职业素养》</p></blockquote><h2 id="软件开发原则"><a href="#软件开发原则" class="headerlink" title="软件开发原则"></a>软件开发原则</h2><p>所有软件项目的根本指导原则是，软件要<strong>易于修改</strong>。如果违背这条原则搭建僵化的结构，就破坏了构建整个行业的经济模型。</p><h2 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h2><p>软件开发人员必须精通的事项：</p><ul><li>设计模式：必须能描述 GOF 书中的全部 24 种模式和，同时还要有 POSA 书中的多数模型的实践经验。</li><li>设计原则：必须了解 SOLID 原则，而且要深刻理解组件设计原则。</li><li>方法：必须理解 XP、Scrum、精益、看板、瀑布、结构化和分析以及结构化编程。</li><li>实践：必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。</li><li>工作：必须了解如何使用 UML 图，DFD 图，结构图，Petri 网络图，状态迁移图表，流程图和决策表。</li></ul><h2 id="不要说“我试试”"><a href="#不要说“我试试”" class="headerlink" title="不要说“我试试”"></a>不要说“我试试”</h2><ul><li>这种类型的描述并不是承诺，实际上并没有实际意义。</li><li>而且这通常意味着你之前评估周期的时候<strong>并没有竭尽全力</strong>，否则为什么在压缩周期的讨论中还要再说“我试试”呢。</li></ul><h2 id="重新定义“完成”"><a href="#重新定义“完成”" class="headerlink" title="重新定义“完成”"></a>重新定义“完成”</h2><ul><li>有的时候，我们自欺欺人的认为任务已经完成的足够好了，然后转入下一项任务。我们会给自己找借口说，其他还没来得及完成的工作可以等到时间更充裕的时候来处理。甚至有的时候，我们会把代码提交定义为”任务完成“。这样显然是错误的。</li><li>真正的任务完成，是已经通过了测试，并且上线完成等。</li></ul><h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><ul><li>编程并非易事。越年轻的程序员可能越没有感觉，毕竟代码只不过是一堆 if 和 while 语句而已。但是随着经验增长，你会开始意识到把这些 if 和 while 语句组装在一起并非易事。不能期望将他们简单的组装到一起就能得到最好的代码。相反，必须小心谨慎地将系统分解为易于理解的单元，同时使得这些单元之间的联系越少越好。</li><li>因此，仅凭一己之力很难写出足够优秀的代码，即使你的技艺足够高超。<strong>也一定能从另外一名程序员的思考和想法中获益。</strong></li></ul><h2 id="重新认识争论"><a href="#重新认识争论" class="headerlink" title="重新认识争论"></a>重新认识争论</h2><ul><li>凡是不能在 5 分钟内解决的争论，都不能通过辩论来解决。争论之所以要花费这么长时间，是因为争论双方都拿不出足够有力的证据，这个时候争论依据的不是事实，而是信念。</li></ul><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><ul><li>成员需要克服个体差异性，默契配合，彼此信任，形成真正有凝聚力的团队，是需要一些时间的。可能需要 6 个月，甚至一年，但是，凝聚力一旦形成，就会产生一种神奇的魔力。团队成员会一起做计划，一起解决问题，一起面对问题，<strong>一起解决一切</strong>。</li></ul><blockquote><p>《代码精进之路》</p></blockquote><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>一般来说我们都知道命名应该有可读性，但是像这里介绍这么详细的并不多。</p><p>例如我们针对命名可以通过固定分段限定词的方式进行统一：</p><ul><li><code>[动作][对象][范畴]</code>，来统一我们的命名，例如 <code>getRevenueTotal(获取总收入)</code>。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释如果是对执行过程的简单复述，那么这样的注释不应该存在。</li><li>我们可以通过函数和中间变量的封装，来减少可以避免的注释。</li></ul><h2 id="错误和错误码"><a href="#错误和错误码" class="headerlink" title="错误和错误码"></a>错误和错误码</h2><p>我们可以通过以下几种方式处理错误（中后台系统比较合适）：</p><ol><li>程序运行期间的错误，一般我们可以通过 Error 打印到日志中，而且这类错误，最好和报警系统进行对接，直接输出到报警系统中。</li><li>API/服务调用错误，这种错误一般通过错误码返回给调用端的同时，也需要在日志做好记录。</li></ol><blockquote><p>关于错误码：错误码我们可以使用数字或者显示化错误码，数字的坏处即我们需要额外维护错误码表，调用者可能并非我们团队，有可能造成沟通障碍。<br>因此，更建议使用<strong>显示化错误码</strong>，并且可以做一个约定：P 代表参数异常，B 代表业务异常，S 代表系统异常，例如：P_Customer_NameIsNull 客户姓名不能为空</p></blockquote><h2 id="代码中的破窗效应"><a href="#代码中的破窗效应" class="headerlink" title="代码中的破窗效应"></a>代码中的破窗效应</h2><p>破窗效应在代码中很常见，通常在我们完成一个功能的时候，都是基于现有代码的改动，如果你可以基于一个现有代码的不良设计完成功能（例如，在已经很混乱的事件订阅类增加一个 Enum、在已经很冗长的 Http 请求列表复制一个新的出来），那么大概率你会这样做而不是重构，<strong>特别是当这个不良设计不是你最初写的时候，就更加可以心安理得的改代码而没有任何负罪感，甚至在 Code Review 的时候都可以有充足的理由：它已经是这样了，这次先上，将来找个时间整体重构才行。</strong></p><h2 id="SLAP"><a href="#SLAP" class="headerlink" title="SLAP"></a>SLAP</h2><p>SLAP：Single Level of Abstraction Principle，抽象层次一致性</p><p>SLAP 要求函数体中的内容必须在同一个抽象层次上，如果高层次抽象和低层次细节杂糅在一起，就会显得凌乱，难以理解。</p><h2 id="如何述职"><a href="#如何述职" class="headerlink" title="如何述职"></a>如何述职</h2><ul><li>方法1: <strong>提出问题，定义问题，分析问题，解决问题，最后展望未来</strong>。这个也是麦肯锡常用的方法。</li><li>方法2: 我们说事情的时候，应该像电影镜头一样，先由远拉近，再由近拉远。从宏观背景，到怎么做的，到结果和思考。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《代码整洁之道-程序员的职业素养》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;软件开发原则&quot;&gt;&lt;a href=&quot;#软件开发原则&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://localhost:4000/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《重构》-读书笔记</title>
    <link href="http://localhost:4000/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://localhost:4000/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-02T06:11:39.000Z</published>
    <updated>2023-10-02T14:15:46.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。<br>重构前，先检查自己是否有一套可靠的测试集，这些测试必须有自我检视的能力。</p><blockquote><p>事实上很多时候，测试集都是被我们忽略的</p></blockquote><p>营地法则：保证你离开的时候代码库一定比原来的更加健壮。</p><p>什么是重构？根据重构这本书的定义，如果有人说他们的代码在重构过程中有一两天的时间是不可用的，基本上可以确定，他们在做的事情不是重构。</p><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><p>事不过三法则（Rule of Three）：第一次做某件事情的时候只管去做，第二次做某件事情的时候会产生反感，但无论如何还是可以去做，第三次再做类似的事情，你就应该重构。</p><blockquote><p>在《代码精进之路》这本书中，也提到了这个原则。</p></blockquote><p>另外的一个时机是，每次要修改时，首先令修改很容易（警告：这件事有时候会很难），然后再进行这次的修改。</p><blockquote><p>比如，笔者最近在做一个长链接客户端 SDK，最初这个 SDK 功能很简单，我直接加功能即可，后面有一次当我要修改的时候，我发现这个 SDK 的修改已经变得异常复杂了，这个时候我知道我应该重构了。</p></blockquote><h2 id="重构法则"><a href="#重构法则" class="headerlink" title="重构法则"></a>重构法则</h2><p>这里对一些我们实际场景中遇到，但是通常会被我们忽视的一些法则进行列举。</p><h3 id="霰弹式修改"><a href="#霰弹式修改" class="headerlink" title="霰弹式修改"></a>霰弹式修改</h3><p>如果我们代码中的模块特别多，如果我们每次遇到一个变化都需要在不同的小模块中做许多小修改，我们所面临的坏味道就是霰弹式修改。<br>这个时候我们需要思考重构，最好我们不同的模块都是正交的。</p><h3 id="慎重注释"><a href="#慎重注释" class="headerlink" title="慎重注释"></a>慎重注释</h3><p>有的时候，我们写注释是因为这段对应的代码逻辑很糟糕。<br>因此当你感觉需要撰写注释的时候，请先尝试重构，试着将所有的注释变成多余。</p><h3 id="提炼变量"><a href="#提炼变量" class="headerlink" title="提炼变量"></a>提炼变量</h3><p>对于复杂语句，提炼变量可以增加可读性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开始重构&quot;&gt;&lt;a href=&quot;#开始重构&quot; class=&quot;headerlink&quot; title=&quot;开始重构&quot;&gt;&lt;/a&gt;开始重构&lt;/h2&gt;&lt;p&gt;如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://localhost:4000/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《架构整洁之道》-读书笔记</title>
    <link href="http://localhost:4000/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://localhost:4000/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-26T06:38:52.000Z</published>
    <updated>2023-10-02T14:15:46.145Z</updated>
    
    <content type="html"><![CDATA[<p>这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么快。</p><p>也因此，本篇博客作为一个读书笔记性质，可能有些地方也并非足够连贯。</p><h2 id="如何看待软件架构设计"><a href="#如何看待软件架构设计" class="headerlink" title="如何看待软件架构设计"></a>如何看待软件架构设计</h2><p>软件架构设计的终极目标：用最小的人力成本来满足构建和维护该系统的需求。</p><p>很多时候，对于一个系统，一开始我们的开发效率接近 100%，然而伴随产品的每次发布，生产力直线下降。工程师的大部分时间都是消耗在对现有系统的修修补补上面，而不是真正完成实际的功能。拆东墙补西墙，周而往复。公司需要的人力成本也因此变多了，但是效益却没有提升。</p><p>初级工程师总是会犯的一个问题是：持续低估良好的设计，整洁的代码的重要性，并且普遍采用一种话术来欺骗自己：我们可以未来在重构代码，产品上线最重要。而实际上，产品上线之后疲于应付新需求已经很累了，就很难有重构的时机。</p><p>实际上，一般软件开发都会被设计成如下三个阶段，这可能并没有错：</p><ol><li>先让代码工作起来</li><li>试图让它变好：通过优化和重构，让人更好地理解代码，并且适应新需求。</li><li>试着让它运行的更快</li></ol><p>所以，我们确实需要理解整洁架构的重要性，避免我们在 1 和 2 循环往复。</p><p>软件设计的第一条原则：不管是为了可测试性还是其他什么东西——<strong>是不变的，就不要依赖于多变的东西。</strong></p><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><p>软件系统的价值维度：行为和架构。</p><p><strong>变更的实施难度应该和变更的范畴成等比关系，而与变更的具体行为无关</strong>。</p><blockquote><p>有的时候，产品经理会表示，我就改一个小点，为什么需要几天时间？开发人员会找一大堆理由，通常不会提及架构的不合理性。实际上这种现象在我毕业入职的第一家公司时有发生。</p></blockquote><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>目前，我们主要有三个编程范式：结构化编程，面向对象编程，函数式编程。这些编程范式都是在 20 世纪被提出来的，而且在有限的时间中估计也不会新增编程范式了。</p><ul><li>结构化编程：if/then/else 和 do/while/util</li><li>面向对象编程</li><li>函数式编程：值不可变，对赋值进行了限制和规范</li></ul><p>三个编程范式，分别限制了 goto 语句、函数指针和赋值语句的使用。</p><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>程序员可以用代码将一些已经证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。</p><p>goto 语句，让我们的程序很难被分成这种小块。</p><p>关于验证：科学理论和科学定律的特点：他们可以被证伪，但是没有办法被证明，实际上现有的编程大部分也采用了这种理念，我们没用使用完整的形式化证明，而是使用测试用例，测试没有问题后，即发布到线上。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>封装、继承、多态都不是面向对象创造出来的，但是确实使用起来更方便了。</li><li>依赖反转也通常是面向对象的特点。</li><li>独立部署：当某个组件的源代码需要修改，仅仅需要重新部署该组件即可，不需要修改其他组件。</li></ul><p><strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师能够构建出某种插件结构，让高层策略性的组件和底层实现的组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。</strong></p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li>所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的，如果变量永远不能被篡改，那就不可能产生竞争或并发更新的问题。如果锁的状态是不可变的，那就永远不会产生死锁问题。</li><li>一个个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离承担度的组件，然后通过合适的机制保护可变量。</li><li>软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑越少越好。</li></ul><p>一种函数式编程理念的开发方式：<br>事件溯源：我们只存储事务记录，不存储具体状态，当需要计算具体状态的时候，我们只需要重头开始计算所有的事务即可。同时，我们也把 CURD 变成了 CR。</p><h2 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h2><p>我们为软件构建中层结构的主要目标：</p><ol><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。</li></ol><p>SOLID 原则 分为以下几点：</p><ul><li>SRP：单一职责原则，任何一个软件模块都应该有且只有一个被修改的原因。避免多人为了不同的目的修改同一份原代码文件。</li><li>OCP：开放封闭原则，通过新增代码来修改原有的行为，而非只靠修改源代码。</li><li>LSP：里氏替换原则，组件方便被替换，每一处使用父类对象的地方，可以使用其子类对象进行替换，而保持其行为不变。</li><li>ISP：接口隔离原则，避免不必要的依赖。</li><li>DIP：依赖反转原则，高层代码不应该依赖底层细节。如果我们想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。<ul><li>优秀的软件架构师会花费很大力气来设计接口，以减少未来对其进行的改动。毕竟在不修改借口的情况下为软件增加新的功能是软件设计的基础常识。</li></ul></li></ul><blockquote><p>实际上我们在实现 TS 库代码的时候经常用到 DIP，比如我们底层代码需要用到上层的一个功能，我们通常定义一个抽象类或者抽象函数，然后由上层来实现，这种场景即是 DIP。<br>例如，在我们写一个库的时候，通常会定义一个抽象，然后由外层传入实现这个 log，而不是在库代码中直接依赖某种 log 实现（可以有一个默认的实现），这个即是 DIP 的一个运用。</p></blockquote><h2 id="组件构建原则"><a href="#组件构建原则" class="headerlink" title="组件构建原则"></a>组件构建原则</h2><p>组件是软件的部署单元。</p><ul><li>REP：复用/发布原则：软件复用的最小粒度应等同于其发布的最小粒度。</li><li>CCP：共同闭包原则：我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。<ul><li><strong>对于大部分项目来说，可维护性的重要性远远大于复用性</strong>（精髓所在，以前一直觉得复用重要，但回头想想，对于一个项目而言，维护成本才是最直观的指标，这里设计修改所需要的人力成本，最终还是利益如何最大化的问题）</li></ul></li><li>CRP：共同复用原则：实际上是 LSP 原则的一个普适版，LSP 原则是建议我们不要依赖带有不需要函数的类，CRP 原则则是建议我们不要依赖带有不需要的类的组件。</li></ul><p>REP 和 CCP 是粘合性原则，他们会让组件变得更大，而 CRP 是排除性原则，它会尽量让组件更小。</p><p>组件耦合原则：</p><ul><li>无依赖环原则：整体依赖应该是一个有向无环图。</li><li>稳定依赖原则：<strong>依赖关系必须要指向更稳定的方向。</strong>我们可以通过组件的依赖和被依赖的关系计算它的位置稳定性。</li><li>稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。稳定的组件应该是抽象的，那么它的稳定性就不会影响到扩展性。</li></ul><h2 id="软件架构流程"><a href="#软件架构流程" class="headerlink" title="软件架构流程"></a>软件架构流程</h2><p>整体包括：运行、维护、开发、部署</p><p>什么是软件架构师？软件架构师实际上应该是能力最强的一群程序员，他们通常会在自身承接编程任务的同时，逐渐引导整个团队向一个能够最大化生产力的系统设计方向演进。所以我们有时候误以为架构师就不写代码了，这当然是错的。</p><p>软件架构设计的三个工作：组件的切分，组件的组合，以及组件的相互通信。</p><p>软件架构设计的终极目标：最大化程序员的生产力，最小化系统的总运营成本。</p><p>关于部署：一般一个系统的部署成本越高，它的可用性就越低</p><blockquote><p>例如在系统早期开发中，我们可能会决定采用某种微服务架构，但当我们实际部署这个系统的时候，我们就会发现微服务的数量已经庞大到令人生畏，这也就是笔者之前所在公司遇到的问题：一开始通过 golang 微服务实现整个系统，后面决定私有化部署后，迁移成本巨大，不得不进行了微服务的合并。</p></blockquote><p>运行：<strong>对于一个因架构设计糟糕而效率低下的系统，我们通常只需要增加更多的存储器与服务器，就能够让它圆满的完成任务。另外，硬件也远远比人力便宜，这也是软件架构对系统运行的影响远远没有它对开发、部署、维护的影响那么深刻的原因</strong><br>笔者现在确实应该意识到这个问题。</p><p>基于以上设计的架构：UI 界面 - 系统独有的业务能力 - 领域普适的业务能力 - 数据库</p><p>重复：<em>架构师经常会钻进一个牛角尖：害怕重复</em>。虽然软件代码编写的原则是 <code>don&#39;t repeat yourself</code>，但是有的时候，对于两个后期发展偏差很大的组件，如果只是存在一些暂时的重复，是我们完全可以容忍的。我们应该根据实际情况来决定是否要重复。</p><h2 id="划分边界"><a href="#划分边界" class="headerlink" title="划分边界"></a>划分边界</h2><p>软件开发技术发展史，就是一个如何想法设法方便增加插件，从而构建一个可扩展，可维护的系统架构的故事，系统的核心业务逻辑必须和其他组件隔离，保持独立，而这些其他组件要么是可以去掉的，要么是有多重实现的。<br>同时，插件部分的变更实际上不应该影响系统核心逻辑的变更。</p><blockquote><p>这里举例：比如说当我们设计一个多节点 server，它依赖一个分布式存储系统，我们不应该在 server 中把这个分布式存储系统默认为 redis, 而应该定义接口能力即可。</p></blockquote><p>如何分层：本质上，所有的软件系统都是一组策略语句的集合。我们需要将这些策略彼此分离，并且将它们按照变更的方式进行重新分组。其中变更的原因，时间和层次相同的策略应该分到一个组件中。反之，变更原因、时间和层次不同的策略应该分属不同的组件。最终它们是一个有向无环图。</p><h2 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h2><ul><li>六边形架构</li><li>DCI 架构</li><li>BCE 架构</li></ul><p>这些架构通常有以下特点：</p><ol><li>独立于框架</li><li>可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web服务以及其他外部元素来进行测试。</li><li>独立于 UI，并且比较方便地在不改动业务逻辑的情况下改动 UI</li><li>独立于数据库，以及独立于其他外部机构</li></ol><p>谦卑对象模式：</p><p>谦卑对象的解读：我们可以将软件模块分为两组，一组是谦卑组，另外一组不是。谦卑组的模块通常比较难写代码进行测试，比如 GUI，这部分代码应该越简单越好。</p><p>门户模式：Facade Pattern<br>外部只能看到 Facade，然后 Facade 内部的 implement 可以有一个或者多个。</p><blockquote><p>这种模式在我们重构项目的时候挺有用的，我们可以实现一个 Facade 类，然后默默把里面的实现灰度或者直接换掉。</p></blockquote><h2 id="服务和架构"><a href="#服务和架构" class="headerlink" title="服务和架构"></a>服务和架构</h2><p>实际上，服务本身只是一种比函数调用成本稍微高的，分割应用程序的一种形式，与数据库无关。</p><p><strong>服务真的解耦了么？因为通常服务不能彼此访问变量，我们会认为这种设计自然就解耦了。但实际上，任何形式的共享数据都会导致强耦合，比如它们依赖同一种数据结构、同一个 schema。而且在这种情况下，它们的 dev ops 也并不是独立的。</strong></p><hr><p>&lt;完&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://localhost:4000/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="架构" scheme="http://localhost:4000/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>React Conf 2021 内容概要</title>
    <link href="http://localhost:4000/2021/12/08/ReactConf2021/"/>
    <id>http://localhost:4000/2021/12/08/ReactConf2021/</id>
    <published>2021-12-08T14:59:00.000Z</published>
    <updated>2023-10-02T14:15:46.138Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/447103166">https://zhuanlan.zhihu.com/p/447103166</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/447103166&quot;&gt;https://zhuanlan.zhihu.com/p/447103166&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="React" scheme="http://localhost:4000/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>PC 开发技术选型：Electron 不是银弹</title>
    <link href="http://localhost:4000/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/"/>
    <id>http://localhost:4000/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/</id>
    <published>2021-09-16T07:01:35.000Z</published>
    <updated>2023-10-02T14:15:46.140Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.electronjs.org/docs">Electron</a> (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。</p><p>也就是说，我们几乎可以使用纯 web 技术，来创建跨平台的 windows 和 macOS 的原生应用，并通过 Node.js addon 能力接入 native 模块。目前市面上，也有一大批知名的应用是使用 Electron 开发的，比如：VS Code、Atom、Microsoft Teams 等（<em>在 macOS 上面一个简单的判断应用是否使用了 Electron 的办法：在应用的 Contents/Frameworks 里面搜索是否有 Electron Framework.framework</em>）。</p><p>但实际上，这篇文章是希望你在选用 Electron 框架前，需要进行慎重的考虑和评估。国内有很多公司，包括一些一线互联网公司的项目是一开始为了快速迭代选择了 Electron，后续实在无法进一步优化，全部推到重来，这实际上反而不利于整体的项目迭代。</p><h1 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h1><p>一般来说，笔者认为有以下几个场景，不适合使用 Electron 进行开发：</p><h2 id="1-无页面或者少量页面的应用"><a href="#1-无页面或者少量页面的应用" class="headerlink" title="1. 无页面或者少量页面的应用"></a>1. 无页面或者少量页面的应用</h2><p>这一点很好理解，Electron 的便利性主要体现在页面相关的开发，如果你的应用几乎没有页面，比如只在顶部状态栏区域有一个按钮，显然就没有必要使用 Electron，直接使用原生的技术栈即可。</p><h2 id="2-对安装包体积限制较为严格的应用"><a href="#2-对安装包体积限制较为严格的应用" class="headerlink" title="2. 对安装包体积限制较为严格的应用"></a>2. 对安装包体积限制较为严格的应用</h2><p>Electron 由于自身携带的基础设施，导致即使你的业务代码不多，初始安装包也会比较大（毕竟接近一个浏览器的大小），在没有你的业务代码的情况下，未经优化的安装包达到了 60MB 左右，而且通常你需要把 node_modules 一起打进去，所以即使你的业务并不复杂，也很容易产生一个接近 100MB 的安装包。</p><p>因此，如果你的业务需要比较极致的包体积优化，那么 Electron 可能并不是一个合适的选择。</p><h2 id="3-多窗口应用"><a href="#3-多窗口应用" class="headerlink" title="3. 多窗口应用"></a>3. 多窗口应用</h2><p>Electron 的进程模型为一个主进程 + 若干渲染进程，每一个渲染进程用于展示一个页面，<strong>即使你的页面是 Hello World，内存占用也达到 50 MB 左右</strong>。</p><p>也就是说，如果你的应用需要同时展示多个窗口，那么就需要多个渲染进程，这样整体的内存占用就会上涨很多，而实际上我们使用原生或者其他的类 cef 的方案，是可以做到一个进程对应多个窗口的。</p><h2 id="4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用"><a href="#4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用" class="headerlink" title="4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用"></a>4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用</h2><p>Electron 基于 web 架构，所以使用 Electron 开发的应用性能一般来说和 web 比较接近，当然，我们可以通过 Node.js addon 加持的方式让部分场景下性能更高（比如直接使用 c++ 实现一些计算密集型的模块，或者独立出一个非 UI 进程，来处理非 UI 逻辑），不过页面 UI 相关的还是会受限制于 web 的天花板。</p><p>所以，一般来说，以下两种情况可能不适用于 Electron：</p><ol><li><p>在 web 场景下，UI 元素操作比较卡顿，达到瓶颈，必须采用性能更高的原生 UI。不过我建议<strong>不要轻易下这个结论</strong>，一般情况下这种性能问题都是写的代码不够极致，建议先从 web 的角度进行性能优化（比如，长列表场景我们可以<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a>来数十倍地提高性能）。</p></li><li><p>对某一项技术有深度依赖，而这项技术在 web 方面存在性能上的天花板。事实上这种情况也并不多见，其中一个合理的场景是视频相关的应用，比如视频会议，或者视频播放器，这类由于 Chrome 本身的渲染流水线的限制，使用 video 标签或者使用 WebGL 都会存在一些性能问题，这个时候我们需要更深入的去进行相关能力的定制，就需要从 Electron 的框架中跳脱出来，或者针对 Electron 进行二次开发。</p></li></ol><blockquote><p>关于 WebGL: 实际上很多 web 开发者会把 WebGL 当作部分场景下性能优化的银弹，但实际上 WebGL 目前存在诸多困境：WebGL 1.0 虽然已经普及，但是其作为 OpenGL ES 2.0 的子集，性能上已经并不特别适用现代硬件架构；而 WebGL 2.0 目前仍然在普及中并且各家厂商意见无法一致；Web GPU 可能是一个更好的解决方案，底层直接对接 D3D12、metal、vulkan 等更底层更先进的图形框架，但目前成熟度不高。</p></blockquote><p>如果你的应用在经过以上分析之后，认为仍然可以使用 Electron 进行开发，那么恭喜你拥有了一个如此高效率的开发方案（如果不行，建议你可以选择其他的解决方案，比如 <a href="https://www.qt.io/">QT</a>）。</p><p>当然在此基础上，我们仍然需要进行充足的性能优化和稳健的架构设计，来让我们应用的可靠性变得更高。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>和 web 不同的是，我们的 native 应用需要更加关注如下三个指标：</p><h2 id="1-cpu"><a href="#1-cpu" class="headerlink" title="1. cpu"></a>1. cpu</h2><p>cpu 占用相关的问题，我们在 web 技术栈中一般也会关注，不过更多的是关注函数的调用耗时，是否存在同步调用的耗时过长导致卡顿等问题。</p><p>而在桌面应用程序的场景中，我们需要从整个应用的维度关注 cpu 消耗，并且需要更加重视。</p><p>另外一个原因是，在网页场景中，页面的 cpu 占用通常不会特别直观地被用户发现（因为系统层面通常只会体现在浏览器占用 cpu 较多），而在现在的原生场景，用户可以直接在任务管理器中看到我们的应用，如果我们的应用持续有一个较高的 cpu 占用，就会比较容易被用户发现，甚至触发系统告警提示强杀应用，这对我们应用的口碑也是一个比较负面的影响。</p><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><p>在桌面应用程序中，内存的使用方式有了一个明显的变化：</p><p>原有的 web 页面，通常是用完即走，而对于 native 应用用户一般会打开很久，这也就意味着我们如果一旦产生内存泄漏或者内存占用比较高的情况，对用户的影响是持续并且被不断放大的。</p><p>对于 cpu 和内存的分析，我们可以通过以下方式：</p><ol><li>开发阶段通过 visual studio 或 instruments 来详细分析我们开发的功能的 cpu 和内存分配情况，发现问题。</li><li>测试发布阶段通过第三方内存分析工具，流程化的分析 cpu 和内存占用并产出报告。</li><li>线上阶段持续监控 cpu 和内存消耗情况，并且上报数据进行统计和监控告警。</li></ol><h2 id="3-crash-率"><a href="#3-crash-率" class="headerlink" title="3. crash 率"></a>3. crash 率</h2><p>实际上在前端领域基本上没有 “crash” 这个说法，不过对于 native 应用来说，即使我们的应用是完全采用前端技术栈，也可能存在 crash (crash 在 Electron 的代码），一般这个时候用户的体验是闪退，相对来说算是严重影响用户体验的问题，因此值得我们足够的重视。</p><p>对于 crash 问题我们应该做好以下三点：</p><ol><li>运行时 crash 监听机制，一般是 sentry 或者直接使用其依赖的 crash_pad。</li><li>符号管理机制，管理我们原生模块，和我们用到的 Electron 对应版本的符号。</li><li>运行时 crash 上报告警机制。</li></ol><h1 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h1><p>除了上述性能指标和监控手段，我们可以通过一定的架构优化，来增强系统的可靠性。</p><h2 id="通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容"><a href="#通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容" class="headerlink" title="通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容"></a>通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容</h2><p>这里的作用主要是希望能够借助原生模块的高性能优化 cpu 的占用。</p><p>Electron 让我们开发 ui 相关的页面变得非常高效，但是一些逻辑部分，或者和操作系统进行交互的部分，我们还是需要原生开发的手段，毕竟即使使用了 Node.js，也无法直接进行系统调用。</p><p>这里我们可以采用 Node.js addon 的方式或者独立进程+进程间通信的方式，两者的好处分别是：</p><p>addon：</p><ol><li>方便进行内存共享。</li></ol><p>独立进程：</p><ol><li>通常会增加可靠性，独立进程挂掉后可以单独重启，不影响用户界面。</li><li>需要防止大块的内存重复占用，可以通过共享内存等方式来进行优化。</li></ol><h2 id="减少或者禁止在渲染进程使用-remote"><a href="#减少或者禁止在渲染进程使用-remote" class="headerlink" title="减少或者禁止在渲染进程使用 remote"></a>减少或者禁止在渲染进程使用 remote</h2><p>有的时候，即使 electron 的技术选型适合你的项目，但如果滥用 remote 也会造成整个应用的大量不稳定与卡顿。</p><p>实际上，我们可以通过阅读 electron 的源代码发现，remote 模块只是对 IPC 消息的同步封装，方便渲染进程调用主进程的对象和方法，而不必显式发送消息进行进程间通信。所以，由于其屏蔽了内部的进程间通信，在调用的时候基本无感主进程的存在和 IPC 的风险，但事实上这却有卡顿甚至卡死渲染进程的风险。</p><p>另外，去掉 remote 还有另外一个好处，就是方便我们项目的 PC 版本和 web 版本进行同构，具有更高的可维护性。</p><p>所以针对一般的项目，笔者建议能禁用就禁用 remote，规避此隐患。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>我们可以在代码编写和打包的过程中，做一些其他的优化，在这里，大部分前端的优化比如动态加载、代码分割、图片缓存等大多也都适用 electron 的情况，除此之外，还有一些优化则是：</p><ol><li><p>避免重复打包：</p><ul><li><strong>避免 node_modules 和 webpack 重复的打包和引入</strong>，对于 webpack 我们可以使用 webpack-bundle-analyzer 来分析打包体积进行优化</li><li>减少无关文件的打包，可以通过配置针对 electron-builder 的 config 去除无关内容打包，同时可以使用 <a href="https://github.com/tj/node-prune">node-prune</a> 来去除无用的 node_modules 小文件。</li></ul></li><li><p><strong>v8-code-cache</strong>: </p><ul><li>可以使用 <a href="https://github.com/zertosh/v8-compile-cache">v8-compile-cache</a> 来进行一定的编译优化</li></ul></li><li><p>更多可以参考 VSCode 的相关分享：<a href="https://www.youtube.com/watch?v=r0OeHRUCCb4">https://www.youtube.com/watch?v=r0OeHRUCCb4</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.electronjs.org/docs&quot;&gt;Electron&lt;/a&gt; (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://localhost:4000/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>web 页面内存分析与生产环境禁用 console</title>
    <link href="http://localhost:4000/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://localhost:4000/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2021-09-04T11:15:01.000Z</published>
    <updated>2023-10-02T14:15:46.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤函数，严格控制 console 的输出。</p><p>但实际上，笔者经历的项目中很多都没有办法做到这一点，虽然我们知道，禁用 console 的主要原因除了信息泄漏的风险外，还有就是 console 打印的内容无法被内存回收。但仍然总是会有一些同学对禁用 console 的必要性表示质疑，在本篇文章中，本文通过两个实际遇到的比较严重的例子，来解释禁用 console 的必要性。</p><blockquote><p>出于保密性考虑，例子本身已经脱敏，本文使用示例代码模拟原始场景。</p></blockquote><h2 id="页面内存"><a href="#页面内存" class="headerlink" title="页面内存"></a>页面内存</h2><p>在具体例子讲解之前，我们需要先对页面内存有一个认知，在前端开发中，我们虽然开发的只是在 Chrome 等浏览器中浏览的页面，但是对页面的 cpu 和 内存占用也需要时刻保持关注。</p><p>cpu 和 内存一般是针对进程级别，chrome 的进程模型比较复杂，一般情况下，我们可以认为同域的页面有比较大的概率进行进程复用。</p><p>Chrome 提供了一些手段，让我们可以监控页面的 cpu 和内存，例如：</p><p>Performance Monitor 可以让我们直观地监测页面的 cpu、js heap 的分配情况等：</p><p><img src="/img/chrome_monitor.png" alt="chrome_monitor"></p><p>Chrome 自身提供了一个任务管理器（More Tools -&gt; Task Manager），可以让我们关注各个页面的性能情况：</p><p><img src="/img/chrome_task_manager.png" alt="chrome_task_manager"></p><p>除了实时监控以外，Chrome DevTools 的 Memory 等 tab 也可以让我们对内存占用进行取样分析，以及内存泄漏分析：</p><ul><li>一般来说，我们可以通过对两次 heap snapshot，然后搜索关键变量的数目与引用关系是否符合预期，来证明是否存在内存泄漏。</li><li>除此之外，我们使用 WeakMap 来跟踪我们的实例，也可以辅助进行一定的内存泄漏分析。</li></ul><h2 id="使用-console-log-打印-dom-元素造成死循环-OOM"><a href="#使用-console-log-打印-dom-元素造成死循环-OOM" class="headerlink" title="使用 console.log 打印 dom 元素造成死循环 OOM"></a>使用 console.log 打印 dom 元素造成死循环 OOM</h2><p>之前笔者负责的一个页面，在某个版本出现了一个问题：打开页面后不久，在什么操作也没有做的情况下直接卡死无响应。</p><p>一般来说，js 导致网页无响应的可能性并不多，我们首先怀疑是因为死循环导致的。</p><p>不过我们通过对比上次和这一次的代码，发现变动极小（实际上，我们一开始都忽略了 console.log），我们通过在 Chrome 的 devTools 里面打断点，最终定位发现是卡死在第三方库 sentry 的 console.log 中。</p><p>最终我们定位出真正的原因：其中一处 try catch 在 catch 到错误之后，会 console.log 打印包括 dom 在内的一些内容，而我们使用的 console.log 被 sentry 进行了覆盖，它的覆盖方法大致如下（这个确实有点坑，以至于我们直接查看 console.log 仍然是 [native code]， 不过最新版本的 Chrome 这个代码已经不能完全 work）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> __native_console = <span class="variable language_">console</span>.<span class="property">log</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 递归遍历各个属性</span></span><br><span class="line">  <span class="title function_">__native_console</span>(...<span class="variable language_">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__native_console</span> = __native_console;</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">__native_console</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">__native_console</span>.<span class="title function_">toString</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 2021.09 @niexiaotao 补充一下最新的实现</span></span><br></pre></td></tr></table></figure><p><strong>这里之所以死循环，是因为 React 中 FiberNode 是 Dom 的其中一个属性，console.log 递归遍历到了 FiberNode，其本质是一个双向链表，最终造成无限递归死循环</strong>。</p><p>我们可以比较方便的随便找个 React 项目验证这一点：</p><p><img src="/img/chrome_fiber.png" alt="React Fiber"></p><h2 id="detached-dom-过多导致页面内存持续上涨"><a href="#detached-dom-过多导致页面内存持续上涨" class="headerlink" title="detached dom 过多导致页面内存持续上涨"></a>detached dom 过多导致页面内存持续上涨</h2><p>另外笔者接触到的一个比较严重的问题，是之前某项目的一个页面，随着使用时间增加，页面的内存使用量快速持续增加，最终导致卡顿和崩溃。</p><p>这个问题的定位过程也比较艰辛，最终发现其中的一个主要原因是 <strong>console.log 打印了 dom 节点，导致 detached dom 持续增多并且无法被回收，最终导致严重问题</strong>。</p><p>关于 detached dom 的问题我们可以使用<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a> 这里的 demo，简单修改：</p><p>将原本需要挂载到 dom 的节点直接进行打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  fragment.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  fragment.<span class="property">innerHTML</span> = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(fragment);</span><br><span class="line">  <span class="comment">// list.appendChild(fragment);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易看到这样就产生了 500 个 detach 节点，并且在页面的生命周期内，无法进行释放：</p><p><img src="/img/chrome_detach_console.png" alt="detach console"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，在生产环境使用 console.log 造成的问题远不止上面的两例，而且这类问题通常排查起来都会比较艰难，因此，建议大家落实在生产环境禁用 console。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://localhost:4000/tags/javascript/"/>
    
    <category term="性能优化" scheme="http://localhost:4000/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>通过优化合成层优化性能</title>
    <link href="http://localhost:4000/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/"/>
    <id>http://localhost:4000/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/</id>
    <published>2021-09-04T05:15:01.000Z</published>
    <updated>2023-10-02T14:15:46.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</p><p>在本篇文章中，主要介绍一个压缩合成层的思路来进行性能优化，关于合成层的文章网上也有一些（附录部分有列出），不过大部分文章会对合成层创建的原因进行冗长的介绍，本文会跳过这些部分。原因是我们通过 devTools 可以比较方便的针对具体情况分析创建合成层的原因，另外一个原因是 blink 已经把创建合成层的原因写到了一个文件中（<a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/graphics/compositing_reasons.cc">传送门</a>），我们直接参考就行，也没有必要去全都记住。</p><h2 id="合成层是什么"><a href="#合成层是什么" class="headerlink" title="合成层是什么"></a>合成层是什么</h2><p>对于 blink 渲染引擎的渲染流程，大致可以分为以下几个阶段：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">om</span> Tree -&gt;</span> L<span class="function"><span class="title">ayout</span> Object -&gt;</span> P<span class="function"><span class="title">aint</span> Layer -&gt;</span> G<span class="function"><span class="title">raphics</span> Layers Tree -&gt;</span> Paint</span><br></pre></td></tr></table></figure><p>我们对以上过程进行一个简述：</p><ul><li>Dom Tree 到 Render Tree 这个过程，基本是一一对应的，除了一些 display:none 的元素。</li><li>Layout Object 会按照一定条件创建 Paint Layer。</li><li>Paint Layer 在到 Graphics Layer 的过程中，会创建合成层（Composite Layer），会对应独立的 Graphics Layer。</li><li>Graphics Layer 会把结果渲染到纹理，最终通过 Chrome 的渲染层以及系统进行上屏。</li></ul><p>实际上我们可以发现，合成层的多少会比较影响我们的渲染性能，合成层比较多的情况下，当我们对页面进行交互（比如滚动），触发重新渲染，就会有卡顿的风险。</p><h2 id="分析合成层"><a href="#分析合成层" class="headerlink" title="分析合成层"></a>分析合成层</h2><p>Chrome 的 DevTools 工具可以让我们比较方便地进行合成层分析，例如我们通过一个 demo 来进行分析：</p><p><img src="/img/composite_reason.png" alt="合成层示例"></p><p>在上图中，我们会发现这个 demo 的合成层比较多，我们点进去可以查看到是因为 overflow 导致创建了新的合成层。</p><p>也就是说，对该 demo 而言我们可以尝试在这些 Demo 中去掉或者修改 overflow 的相关设置，从而进行合成层优化。</p><h2 id="优化合成层"><a href="#优化合成层" class="headerlink" title="优化合成层"></a>优化合成层</h2><p>我们尝试去掉 <code>overflow: scroll;</code>。（ Demo 源代码会在本文最后给出）</p><p>然后我们设置页面的列表元素为 500 个，通过模拟页面持续滚动，来检查去掉前后的性能。</p><p>去掉前，cpu 保持在 50%+，这实际上已经是一个比较高的数值了：</p><p><img src="/img/composite_cpu_1.png" alt="合成层cpu"></p><p>去掉后，cpu 保持在 2% 左右：</p><p><img src="/img/composite_cpu_2.png" alt="去除合成层cpu"></p><p>我们可以看到，优化后有巨大的性能提升，这种量级的性能提升，会远超虚拟滚动等方案（其实我个人是不建议采用虚拟滚动的，非常难维护，而且你很难做到浏览器原生滚动的丝滑水准）。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> &gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.list</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">90vh</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">overflow</span>: scroll;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">    <span class="selector-class">.li</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-bottom</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border-color</span>: grey;</span></span><br><span class="line"><span class="language-css">      <span class="comment">/* overflow: scroll; */</span></span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> totalListCount = <span class="number">500</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.list&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">let</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    fragment.<span class="property">classList</span>.<span class="title function_">add</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    fragment.<span class="property">innerHTML</span> = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="language-javascript">    list.<span class="title function_">appendChild</span>(fragment);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> renderScroll = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    curr += <span class="number">5</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (curr &gt;= totalListCount) curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">    list.<span class="property">children</span>[curr].<span class="title function_">scrollIntoView</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">requestAnimationFrame</span>(renderScroll)</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">renderScroll</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li>Compositing Layers: <a href="https://zhuanlan.zhihu.com/p/88288584">https://zhuanlan.zhihu.com/p/88288584</a></li><li>前端性能优化之 Composite: <a href="https://segmentfault.com/a/1190000015917498">https://segmentfault.com/a/1190000015917498</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</summary>
      
    
    
    
    
    <category term="性能优化" scheme="http://localhost:4000/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>了解 StackOverFlow 上面最受欢迎的语言 Rust</title>
    <link href="http://localhost:4000/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/"/>
    <id>http://localhost:4000/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/</id>
    <published>2021-09-02T11:15:51.000Z</published>
    <updated>2023-10-02T14:15:46.142Z</updated>
    
    <content type="html"><![CDATA[<p>本文希望从宏观角度，来介绍和分析 Rust 语言。</p><p>Rust 是一门<strong>专注安全</strong>的现代系统编程语言，发布于 2015 年。</p><p>自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言，而且和第二名还能拉开不小的差距，例如最近两年的统计数据：</p><p><a href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted">2020</a>:<br><img src="/img/rust_2020.png" alt="2020_rust"></p><p><a href="https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread">2021</a>:<br><img src="/img/rust_2021.png" alt="2021_rust"></p><p>接下来笔者通过性能、可靠性、生产力、面向前端友好等几个维度来介绍 Rust，之后会对 Rust 的部分重点语言特性进行介绍。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>首先作为一种编译型语言，可以直接将编译产物作为二进制可执行文件部署，无需随程序一起分发解释器和大量的依赖项，因此相对于 Python、Ruby 以及 Javascript 等解释型语言，会效率更高。</p><p>同时，Rust 提供了大量的零成本抽象（如泛型、async/await、迭代和闭包等），在保证开发效率的同时避免了运行时开销。</p><p>一般来说，Rust 的性能和 C/C++ 相似，无虚拟机，无 GC，运行时仅依赖 libc，<strong>在需要高性能场景中使用已经足够</strong>。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在一个 c++ 项目中，我们经常会遇到各类 crash，处理这些 crash 通常会花费大量的人力。</p><p>而在一个 Rust 项目中，如果规范使用基本上在编译阶段就可以避免几乎所有的 crash，也就是说，<strong>使用 Rust 的项目只要编译通过，就只有逻辑错误，不会再有 crash</strong>（自身使用了 unsafe 除外）。</p><p>Rust 之所以能做到这一点，得益于其设计的所有权、生命周期、Option 机制以及智能指针等，这一点我们在下文的语言特性中也会更详细地分开介绍。</p><blockquote><p>实际上，笔者现在负责的项目中 Rust 和 C++ 大约各有一半的代码，在这其中 Rust 几乎没有出现过 crash，而 c++ 基本上每双周（一个迭代）都会新增一些种类的 crash。</p></blockquote><h2 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h2><h3 id="代码开发效率"><a href="#代码开发效率" class="headerlink" title="代码开发效率"></a>代码开发效率</h3><p>得益于 Rust 的大量零成本抽象，以及 Rust 提供的高度灵活的宏机制，我们的代码开发效率还是比较高的。就笔者的体验而言，使用 Rust 完成功能的开发效率略低于 Typescript，但是远高于 c++（和 Typescript 相比，Rust 通常会需要花费额外的一些时间来解决编译问题，但是换来的是高性能和稳定性，我认为这是值得的）。</p><p>另外随着 Rust 语言的逐渐成熟，配套的 IDE 和编辑器（Clion、VSCode）也逐渐成熟，日常代码开发提示、以及代码调试等都非常方便。</p><h3 id="包管理系统"><a href="#包管理系统" class="headerlink" title="包管理系统"></a>包管理系统</h3><p>另外值得一提的是，Rust 的包管理系统非常强大，这一点我认为 Rust 也参考了 npm，包管理系统的使用体验也和 npm 比较接近，新增一个依赖，只需要在 Cargo.toml 配置文件中新增一行配置即可。方便的包管理系统，让我们可以方便地复用<a href="https://crates.io/">社区各类优秀的资源</a>。</p><p>相对来说，c++ 这类老牌语言的包分发和管理就会麻烦很多，甚至在一个项目内也会比较麻烦。</p><h3 id="现有资源的复用"><a href="#现有资源的复用" class="headerlink" title="现有资源的复用"></a>现有资源的复用</h3><p>这一点主要是 Rust 和 C/C++ 的互相调用，Rust 支持调用 C 接口和封装成 C 接口被其他语言所调用，因此对于现有的项目，如果可以提供一层 C 接口的封装，就会比较方便地被 Rust 直接调用。</p><h2 id="面向前端友好"><a href="#面向前端友好" class="headerlink" title="面向前端友好"></a>面向前端友好</h2><p>我认为 Rust 面向前端友好主要体现在两个方面：</p><h3 id="虽然学习路线陡峭，但和-Typescript-相近点较多"><a href="#虽然学习路线陡峭，但和-Typescript-相近点较多" class="headerlink" title="虽然学习路线陡峭，但和 Typescript 相近点较多"></a>虽然学习路线陡峭，但和 Typescript 相近点较多</h3><p>很多人劝退 Rust 理由之一是其学习曲线陡峭，但是实际上前端同学学习 Rust 会比学习 C++ 容易的多，一方面，Rust 的很多机制（async/await、类的设计、包管理）等都和 Typescript 有相似之处，另外一方面写 Rust 只要编译能够通过基本上能够保证你代码质量的下限，也就是说基本上可以上线生产环境。而 C++ 新手写出来的代码通常会有各种 crash 隐患，而且排查通常较为困难，导致容易背锅，这一点来说对新手非常不友好。</p><h3 id="面向-WASM-友好"><a href="#面向-WASM-友好" class="headerlink" title="面向 WASM 友好"></a>面向 WASM 友好</h3><p>对于 WebAssembly，笔者并不推荐 AssemblyScript，因为其虽然是 “Typescript”，但是使用起来和 Typescript 相差太多，而且无法完全直接使用 JavaScript 的第三方库，调试等也并不是很方便。</p><p>而剩余的几类语言中（Rust、C++、Kotin、Golang），相对来说 Rust 和 C++ 的 wasm 编译都较为成熟，Rust 更是在设计之初即考虑支持 WebAssembly 并且将其作为一个主要亮点，被 Rust 官方团队直接维护（包含了勤劳的 Alex Crichton，其也是 tokio 的作者）。因此我们使用 Rust 编译 WebAssembly 非常方便，并且可以直接使用大多数第三方 Rust 库，使用体验和 Rust Native 开发基本上没有差异。</p><p>目前笔者的项目中，有一部分模块即使用了 Rust + WebAssembly，同时支持了 Windows/Mac/iOS/Android/Web 五种平台，并且几乎都做到了最高性能。</p><blockquote><p>当然不得不承认，Rust 编译 WebAssembly 在使用到 C++ 的资源时也并不是十分方便，Rust 的 WASM 编译器和 Emscripten 也有诸多差异，适配起来会比较头疼，如果现有项目主要是 C++，还是建议直接使用 Emscripten。</p></blockquote><h2 id="重点语言特性"><a href="#重点语言特性" class="headerlink" title="重点语言特性"></a>重点语言特性</h2><p>Rust 拥有大多现代语言具备的特性，比如 RAII、动态数据类型等，另外还有不少设计是 Rust 中独有的，下面我们对一些 Rust 中比较独特的语言特性进行一些介绍。</p><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>Rust 的所有权机制，即一个值同一个时刻只能被一个变量所引用，我们来看一个简单的例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// 提示报错：value borrowed here after move</span></span><br></pre></td></tr></table></figure><p>因为我们把 a 对应的数据的所有权给到了 b，也就是说 a 不再拥有对应的数据的所有权，因此也无法访问，<strong>这种机制保证了数据安全，能够有效避免悬垂指针的发生</strong>。</p><p>当然，对于实现了 Copy（一般来说，都是存储在栈上面的简单数据类型），在赋值阶段会自动拷贝，或者对于没有实现 Copy，但是实现了 Clone（需要主动调用）的类型我们显式调用 Clone，都可以编译通过，这些设计给我们的日常开发中带来了极大的便利：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>: <span class="type">i32</span> = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="string">&quot;hello&quot;</span>.<span class="title function_ invoke__">to_string</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = a.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>在 Rust 中，一般情况下并没有空指针的概念，并不像 c++ 有 nullptr、java 有 null，Rust 中如果表示一个可空的内容只能使用 Option（有点类似 C++ 的 std::optional）。</p><p>除了 Option，Rust 还封装了若干种高级指针，并对不同类型的指针的行为进行限制，以提高其安全性：</p><ul><li>Box：用于在堆上存储数据，<strong>单一所有权</strong>（即一般情况下不会存在一个指针乱飞的情况），可以用于封装在编译时未知大小的类型。</li><li>Rc：引用计数指针，不支持多线程</li><li>Arc：多线程版本的引用计数指针</li><li>RefCell：保持内部可变性的指针，即我们如果希望多个所有者共同拥有并且都可以修改的指针，需要结合 Rc 或 Arc 加 RefCell 一起使用。‘</li></ul><p>Rust 还提供了一些其他类型的智能指针，在这里不再过多介绍，虽然这里的大部分概念 c++ 也存在，但是 Rust 基本只能是强制你使用这些内容，而无法使用不安全的裸指针。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Rust 中的多态有基于泛型的静态派发和基于 trait 的动态派发。</p><ul><li>静态派发：是一种零成本抽象，在 C++ 中也有类似的概念，静态派发是通过对不同类型的调用在编译期间生成不同版本的代码来实现的，不会引入运行时开销（但请注意可能会造成代码体积膨胀）。</li><li>动态派发：有些场景下，我们没有办法在编译期间确定变量的实际类型，进而无法确定其占用内存大小，Rust 也提供了 trait 机制来实现动态派发，同时 Rust 将此类 trait 使用 dyn 进行显式指定：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态派发：</span></span><br><span class="line"><span class="keyword">trait</span> <span class="title class_">Speak</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello</span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Human</span>;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Speak</span> <span class="keyword">for</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello, I am a Human&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test_hello</span>(someone: <span class="type">Box</span>&lt;<span class="keyword">dyn</span> Speak&gt;) &#123;</span><br><span class="line">    someone.<span class="title function_ invoke__">hello</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">human</span> = Human &#123;&#125;;</span><br><span class="line">    <span class="title function_ invoke__">test_hello</span>(<span class="type">Box</span>::<span class="title function_ invoke__">new</span>(human));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>Rust 中的宏的能力非常强大，其不同于 C/C++ 中的宏简单地按字符串替换代码，而是基于语法树进行操作，在编译阶段被展开成源代码进行嵌入。</p><p>具体 Rust 中的宏也分为声明宏和过程宏，能够实现的需求非常多样，在一个大型项目中，我们可以通过宏的使用解放生产力，并且使代码更清晰。不过，宏这一部分的具体学习相对比较复杂，在这里便不再进行举例。</p><hr><p>综合来说，Rust 作为一个比较先进的语言，没有太多的历史包袱，从各个语言中吸收了不少的优质特性，比较适合我们在新项目的技术选型中作为一个考虑因素。</p><h2 id="如何开始学习-rust"><a href="#如何开始学习-rust" class="headerlink" title="如何开始学习 rust"></a>如何开始学习 rust</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>rust 本身的文档和学习资料官方提供的比较全面，一个必读的内容是<a href="https://doc.rust-lang.org/book/">“The Rust Programming Language”</a>。</p><p>不过，rust 的官方文档读起来可能略有枯燥，这个时候我建议可以先开始读<em>张汉东</em>的《Rust 编程之道》，相对来说更加深入浅出，不过还是后续还是建议读一遍文档。</p><h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><p>在我们将上述内容读完之后（如果每天两个小时的话，大约需要一个月的时间），具备了一定的 Rust 语言基础，可能需要思考下如何在现有项目中落地，我个人的一个建议是：</p><ul><li>如果现有项目是偏 web 的，可以先考虑通过 wasm 来落地，相对来说上手成本很低，我之前也对<a href="https://zhuanlan.zhihu.com/p/104299612">入门 Rust 开发 WebAssembly</a>有所总结。</li><li>如果现有项目是偏 native 的，可以考虑将部分新模块、或者 crash 告警比较多的逻辑部分，使用 rust 实现并且通过 C FFI 和现有模块进行交互，渐进式引入 Rust 技术栈。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文希望从宏观角度，来介绍和分析 Rust 语言。&lt;/p&gt;
&lt;p&gt;Rust 是一门&lt;strong&gt;专注安全&lt;/strong&gt;的现代系统编程语言，发布于 2015 年。&lt;/p&gt;
&lt;p&gt;自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言</summary>
      
    
    
    
    
    <category term="Rust" scheme="http://localhost:4000/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>一些性能相关的 JavaScript 代码编写建议规范</title>
    <link href="http://localhost:4000/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/"/>
    <id>http://localhost:4000/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/</id>
    <published>2021-08-29T05:59:00.000Z</published>
    <updated>2023-10-02T14:15:46.142Z</updated>
    
    <content type="html"><![CDATA[<p>本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。</p><blockquote><p>本文比较零碎，不作为规范提议，仅作为交流参考。</p></blockquote><h3 id="1-使用解构赋值，减少中间变量。"><a href="#1-使用解构赋值，减少中间变量。" class="headerlink" title="1. 使用解构赋值，减少中间变量。"></a>1. 使用解构赋值，减少中间变量。</h3><p>对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</span><br><span class="line">[<span class="meta">b, a</span>] = [a, b];</span><br></pre></td></tr></table></figure><h3 id="2-通过条件判断提前返回"><a href="#2-通过条件判断提前返回" class="headerlink" title="2. 通过条件判断提前返回"></a>2. 通过条件判断提前返回</h3><p>这里主要是提醒大家如何写好 if 语句。</p><p>实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以<strong>逻辑外化</strong>：</p><p>即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。</p><p>经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：</p><ul><li>if 语句先简单，后复杂。</li><li>if 语句，可以提前返回即提前返回，减少复杂的嵌套。</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nice:</span></span><br><span class="line">if (condition1) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (condition2) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">other_function</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad:</span></span><br><span class="line">if (condition1) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">  if (condition2) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    <span class="built_in">other_function</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免在循环体内包裹函数表达式"><a href="#3-尽量避免在循环体内包裹函数表达式" class="headerlink" title="3. 尽量避免在循环体内包裹函数表达式"></a>3. 尽量避免在循环体内包裹函数表达式</h3><p>函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nice:</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">callback</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len = nodelist.<span class="property">length</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="title function_">addListener</span>(nodelist[i], callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodelist.<span class="property">length</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="title function_">addListener</span>(nodelist[i], <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对循环体内的不变值，在循环体外使用缓存"><a href="#4-对循环体内的不变值，在循环体外使用缓存" class="headerlink" title="4. 对循环体内的不变值，在循环体外使用缓存"></a>4. 对循环体内的不变值，在循环体外使用缓存</h3><p>这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。</p><h3 id="5-清空数组使用-length-0"><a href="#5-清空数组使用-length-0" class="headerlink" title="5. 清空数组使用 .length = 0"></a>5. 清空数组使用 .length = 0</h3><p>这样写可以方便我们清空一个 const 数组。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 如果使用 a = [] 会报错</span></span><br><span class="line">a.<span class="built_in">length</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="6-不得为了编写方便，将并行的-io-串行化"><a href="#6-不得为了编写方便，将并行的-io-串行化" class="headerlink" title="6. 不得为了编写方便，将并行的 io 串行化"></a>6. 不得为了编写方便，将并行的 io 串行化</h3><p>虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> res1 = <span class="built_in">await</span> process1();</span><br><span class="line"><span class="keyword">let</span> res2 = <span class="built_in">await</span> process2();</span><br><span class="line"><span class="keyword">next</span>(res1, res2);</span><br></pre></td></tr></table></figure><p>这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#">方法</a>，我认为这些都是必须要了解的。</p><h3 id="7-禁止直接使用-eval"><a href="#7-禁止直接使用-eval" class="headerlink" title="7. 禁止直接使用 eval"></a>7. 禁止直接使用 eval</h3><p>eval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。</p><p>如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> tip = <span class="string">&quot;请重新登录&quot;</span></span><br><span class="line"><span class="built_in">let</span> otherCode = `tip = <span class="string">&quot;请前往 xxx.com 重新登录&quot;</span>`</span><br><span class="line"><span class="built_in">eval</span>(otherCode);</span><br></pre></td></tr></table></figure><p>一些取代方式：</p><p>我们可以使用 <code>new Function</code> 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。</p><h3 id="8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll"><a href="#8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll" class="headerlink" title="8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll"></a>8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll</h3><p>类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。</p><h3 id="9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle"><a href="#9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle" class="headerlink" title="9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle"></a>9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle</h3><p>通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。</p><h3 id="10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。"><a href="#10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。" class="headerlink" title="10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。"></a>10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。</h3><p>直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文比较零碎，不作为规范提议，仅作为交流参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-使用解构赋值，减少中间变量。&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="javascript" scheme="http://localhost:4000/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何让你的精力更多的用于提高技术深度</title>
    <link href="http://localhost:4000/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/"/>
    <id>http://localhost:4000/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/</id>
    <published>2021-07-26T15:42:20.000Z</published>
    <updated>2023-10-02T14:15:46.145Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/395177123">知乎版本</a></p><p>题目所述，就是我最近很久一段时间都在用来思考的问题。</p><p>先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。</p><p>在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。</p><p>因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。</p><p>当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。</p><p>不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。</p><p><strong>这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间</strong></p><h2 id="1-提高对代码的要求，写更好的代码"><a href="#1-提高对代码的要求，写更好的代码" class="headerlink" title="1. 提高对代码的要求，写更好的代码"></a>1. 提高对代码的要求，写更好的代码</h2><p>我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。</p><p>我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。</p><p>因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。</p><p>那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：</p><ul><li><strong>请熟读文档</strong>，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。</li><li>注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。</li><li>除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。</li><li>CI/CD 的建设，保证合并的代码是能够编译的。</li><li>对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，<strong>禁止</strong>直接使用 JavaScript。</li><li>团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。</li></ul><h2 id="2-日志是语言的另一面，也很能体现代码水平"><a href="#2-日志是语言的另一面，也很能体现代码水平" class="headerlink" title="2. 日志是语言的另一面，也很能体现代码水平"></a>2. 日志是语言的另一面，也很能体现代码水平</h2><p>这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。</p><p>这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？</p><p>“日志不足/没打日志，需要加日志进一步定位”。</p><p>不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。</p><p>那么一个好的日志应该是什么样的呢？</p><ol><li>前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。</li><li>关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是<strong>不同负责模块之间衔接的日志，一定打全</strong>，这样之后甩锅的时候有实锤也会方便一点。</li><li>关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。</li><li>日志也需要<strong>向前兼容</strong>，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。</li></ol><p>什么？你说你们团队还没有日志系统？</p><p>那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。</p><h2 id="3-打破边界有助于开阔视野，但是是否深入需要慎重决定"><a href="#3-打破边界有助于开阔视野，但是是否深入需要慎重决定" class="headerlink" title="3. 打破边界有助于开阔视野，但是是否深入需要慎重决定"></a>3. 打破边界有助于开阔视野，但是是否深入需要慎重决定</h2><p>虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。</p><blockquote><p>为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p></blockquote><p>为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：</p><ul><li>在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。</li><li>在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。</li></ul><p>当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。</p><h2 id="4-复杂系统的初始架构设计，可以作为一个最后兜底"><a href="#4-复杂系统的初始架构设计，可以作为一个最后兜底" class="headerlink" title="4. 复杂系统的初始架构设计，可以作为一个最后兜底"></a>4. 复杂系统的初始架构设计，可以作为一个最后兜底</h2><p>实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。</p><p>这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。</p><p>这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。</p><p>虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。</p><p>（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。</p><p>如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。</p><h2 id="5-持续练习，持续关注行业动态"><a href="#5-持续练习，持续关注行业动态" class="headerlink" title="5. 持续练习，持续关注行业动态"></a>5. 持续练习，持续关注行业动态</h2><p>最后一点，持续学习，大概是程序员的宿命吧。</p><p>这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。</p><p>比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。</p><hr><p>以上共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/395177123&quot;&gt;知乎版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目所述，就是我最近很久一段时间都在用来思考的问题。&lt;/p&gt;
&lt;p&gt;先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://localhost:4000/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
</feed>
